Grammar:

Rule 0     S' -> program
Rule 1     program -> instructions_or_empty
Rule 2     instructions_or_empty -> <empty>
Rule 3     instructions_or_empty -> instructions
Rule 4     instructions -> instruction
Rule 5     instructions -> instructions instruction
Rule 6     instruction -> { instructions }
Rule 7     instruction -> BREAK ;
Rule 8     instruction -> CONTINUE ;
Rule 9     instruction -> print_i ;
Rule 10    instruction -> assign ;
Rule 11    instruction -> while_l
Rule 12    instruction -> for_l
Rule 13    instruction -> return_i ;
Rule 14    instruction -> if_i
Rule 15    if_i -> IF ( expr ) instruction ELSE error
Rule 16    if_i -> IF ( expr ) error ELSE instruction  [precedence=right, level=2]
Rule 17    if_i -> IF ( expr ) error  [precedence=right, level=1]
Rule 18    if_i -> IF ( error ) instruction ELSE instruction  [precedence=right, level=2]
Rule 19    if_i -> IF ( error ) instruction  [precedence=right, level=1]
Rule 20    if_i -> IF ( expr ) instruction ELSE instruction  [precedence=right, level=2]
Rule 21    if_i -> IF ( expr ) instruction  [precedence=right, level=1]
Rule 22    while_l -> WHILE ( expr ) error
Rule 23    while_l -> WHILE ( error ) instruction
Rule 24    while_l -> WHILE ( expr ) instruction
Rule 25    for_l -> FOR ID = expr : expr error
Rule 26    for_l -> FOR ID = expr : error instruction
Rule 27    for_l -> FOR ID = error : expr instruction
Rule 28    for_l -> FOR ID = expr : expr instruction
Rule 29    return_i -> RETURN error
Rule 30    return_i -> RETURN expr
Rule 31    return_i -> RETURN
Rule 32    print_i -> PRINT error
Rule 33    print_i -> PRINT printargs
Rule 34    printargs -> expr
Rule 35    printargs -> expr , printargs
Rule 36    expr -> mat_fun ( error )
Rule 37    expr -> mat_fun ( mat_fun_args )
Rule 38    expr -> vector
Rule 39    expr -> expr DOTMINUS expr  [precedence=left, level=7]
Rule 40    expr -> expr DOTPLUS expr  [precedence=left, level=7]
Rule 41    expr -> expr DOTDIVIDE expr  [precedence=left, level=8]
Rule 42    expr -> expr DOTMULTIPLY expr  [precedence=left, level=8]
Rule 43    expr -> expr OR expr  [precedence=left, level=3]
Rule 44    expr -> expr AND expr  [precedence=left, level=3]
Rule 45    expr -> expr XOR expr  [precedence=left, level=3]
Rule 46    expr -> expr GTE expr  [precedence=nonassoc, level=9]
Rule 47    expr -> expr LTE expr  [precedence=nonassoc, level=9]
Rule 48    expr -> expr GT expr  [precedence=nonassoc, level=9]
Rule 49    expr -> expr LT expr  [precedence=nonassoc, level=9]
Rule 50    expr -> expr NEQ expr  [precedence=nonassoc, level=9]
Rule 51    expr -> expr EQ expr  [precedence=nonassoc, level=9]
Rule 52    expr -> expr / expr  [precedence=left, level=6]
Rule 53    expr -> expr * expr  [precedence=left, level=6]
Rule 54    expr -> expr - expr  [precedence=left, level=5]
Rule 55    expr -> expr + expr  [precedence=left, level=5]
Rule 56    expr -> unary
Rule 57    expr -> ( expr )
Rule 58    expr -> var
Rule 59    expr -> FLOATNUM
Rule 60    expr -> INTNUM
Rule 61    expr -> STRING
Rule 62    var -> ID
Rule 63    var -> matel
Rule 64    matel -> ID [ mat_ref_args ]
Rule 65    mat_ref_args -> expr : expr
Rule 66    mat_ref_args -> mat_ref_args , expr : expr
Rule 67    mat_ref_args -> expr
Rule 68    mat_ref_args -> mat_ref_args , expr
Rule 69    assign -> var DIVIDEASSIGN error
Rule 70    assign -> var MULTIPLYASSIGN error
Rule 71    assign -> var MINUSASSIGN error
Rule 72    assign -> var PLUSASSIGN error
Rule 73    assign -> var = error
Rule 74    assign -> var DIVIDEASSIGN expr  [precedence=right, level=4]
Rule 75    assign -> var MULTIPLYASSIGN expr  [precedence=right, level=4]
Rule 76    assign -> var MINUSASSIGN expr  [precedence=right, level=4]
Rule 77    assign -> var PLUSASSIGN expr  [precedence=right, level=4]
Rule 78    assign -> var = expr  [precedence=right, level=4]
Rule 79    unary -> expr '  [precedence=left, level=10]
Rule 80    unary -> NOT expr  [precedence=right, level=11]
Rule 81    unary -> - expr  [precedence=right, level=11]
Rule 82    vector -> [ variables ]
Rule 83    variables -> expr
Rule 84    variables -> variables , expr
Rule 85    mat_fun_args -> expr
Rule 86    mat_fun_args -> mat_fun_args , expr
Rule 87    mat_fun -> ONES
Rule 88    mat_fun -> EYE
Rule 89    mat_fun -> ZEROS

Terminals, with rules where they appear:

'                    : 79
(                    : 15 16 17 18 19 20 21 22 23 24 36 37 57
)                    : 15 16 17 18 19 20 21 22 23 24 36 37 57
*                    : 53
+                    : 55
,                    : 35 66 68 84 86
-                    : 54 81
/                    : 52
:                    : 25 26 27 28 65 66
;                    : 7 8 9 10 13
=                    : 25 26 27 28 73 78
AND                  : 44
BREAK                : 7
CONTINUE             : 8
DIVIDEASSIGN         : 69 74
DOTDIVIDE            : 41
DOTMINUS             : 39
DOTMULTIPLY          : 42
DOTPLUS              : 40
ELSE                 : 15 16 18 20
EQ                   : 51
EYE                  : 88
FLOATNUM             : 59
FOR                  : 25 26 27 28
GT                   : 48
GTE                  : 46
ID                   : 25 26 27 28 62 64
IF                   : 15 16 17 18 19 20 21
INTNUM               : 60
LT                   : 49
LTE                  : 47
MINUSASSIGN          : 71 76
MULTIPLYASSIGN       : 70 75
NEQ                  : 50
NOT                  : 80
ONES                 : 87
OR                   : 43
PLUSASSIGN           : 72 77
PRINT                : 32 33
RETURN               : 29 30 31
STRING               : 61
WHILE                : 22 23 24
XOR                  : 45
ZEROS                : 89
[                    : 64 82
]                    : 64 82
error                : 15 16 17 18 19 22 23 25 26 27 29 32 36 69 70 71 72 73
{                    : 6
}                    : 6

Nonterminals, with rules where they appear:

assign               : 10
expr                 : 15 16 17 20 21 22 24 25 25 26 27 28 28 30 34 35 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 57 65 65 66 66 67 68 74 75 76 77 78 79 80 81 83 84 85 86
for_l                : 12
if_i                 : 14
instruction          : 4 5 15 16 18 18 19 20 20 21 23 24 26 27 28
instructions         : 3 5 6
instructions_or_empty : 1
mat_fun              : 36 37
mat_fun_args         : 37 86
mat_ref_args         : 64 66 68
matel                : 63
print_i              : 9
printargs            : 33 35
program              : 0
return_i             : 13
unary                : 56
var                  : 58 69 70 71 72 73 74 75 76 77 78
variables            : 82 84
vector               : 38
while_l              : 11


state 0

    (0) S' -> . program
    (1) program -> . instructions_or_empty
    (2) instructions_or_empty -> .
    (3) instructions_or_empty -> . instructions
    (4) instructions -> . instruction
    (5) instructions -> . instructions instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    $end            reduce using rule 2 (instructions_or_empty -> .)
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    program                        shift and go to state 1
    instructions_or_empty          shift and go to state 2
    instructions                   shift and go to state 3
    instruction                    shift and go to state 4
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 1

    (0) S' -> program .


state 2

    (1) program -> instructions_or_empty .
    $end            reduce using rule 1 (program -> instructions_or_empty .)


state 3

    (3) instructions_or_empty -> instructions .
    (5) instructions -> instructions . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    $end            reduce using rule 3 (instructions_or_empty -> instructions .)
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 22
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 4

    (4) instructions -> instruction .
    {               reduce using rule 4 (instructions -> instruction .)
    BREAK           reduce using rule 4 (instructions -> instruction .)
    CONTINUE        reduce using rule 4 (instructions -> instruction .)
    PRINT           reduce using rule 4 (instructions -> instruction .)
    WHILE           reduce using rule 4 (instructions -> instruction .)
    FOR             reduce using rule 4 (instructions -> instruction .)
    RETURN          reduce using rule 4 (instructions -> instruction .)
    IF              reduce using rule 4 (instructions -> instruction .)
    ID              reduce using rule 4 (instructions -> instruction .)
    $end            reduce using rule 4 (instructions -> instruction .)
    }               reduce using rule 4 (instructions -> instruction .)


state 5

    (6) instruction -> { . instructions }
    (4) instructions -> . instruction
    (5) instructions -> . instructions instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instructions                   shift and go to state 23
    instruction                    shift and go to state 4
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 6

    (7) instruction -> BREAK . ;
    ;               shift and go to state 24


state 7

    (8) instruction -> CONTINUE . ;
    ;               shift and go to state 25


state 8

    (9) instruction -> print_i . ;
    ;               shift and go to state 26


state 9

    (10) instruction -> assign . ;
    ;               shift and go to state 27


state 10

    (11) instruction -> while_l .
    {               reduce using rule 11 (instruction -> while_l .)
    BREAK           reduce using rule 11 (instruction -> while_l .)
    CONTINUE        reduce using rule 11 (instruction -> while_l .)
    PRINT           reduce using rule 11 (instruction -> while_l .)
    WHILE           reduce using rule 11 (instruction -> while_l .)
    FOR             reduce using rule 11 (instruction -> while_l .)
    RETURN          reduce using rule 11 (instruction -> while_l .)
    IF              reduce using rule 11 (instruction -> while_l .)
    ID              reduce using rule 11 (instruction -> while_l .)
    $end            reduce using rule 11 (instruction -> while_l .)
    }               reduce using rule 11 (instruction -> while_l .)
    ELSE            reduce using rule 11 (instruction -> while_l .)


state 11

    (12) instruction -> for_l .
    {               reduce using rule 12 (instruction -> for_l .)
    BREAK           reduce using rule 12 (instruction -> for_l .)
    CONTINUE        reduce using rule 12 (instruction -> for_l .)
    PRINT           reduce using rule 12 (instruction -> for_l .)
    WHILE           reduce using rule 12 (instruction -> for_l .)
    FOR             reduce using rule 12 (instruction -> for_l .)
    RETURN          reduce using rule 12 (instruction -> for_l .)
    IF              reduce using rule 12 (instruction -> for_l .)
    ID              reduce using rule 12 (instruction -> for_l .)
    $end            reduce using rule 12 (instruction -> for_l .)
    }               reduce using rule 12 (instruction -> for_l .)
    ELSE            reduce using rule 12 (instruction -> for_l .)


state 12

    (13) instruction -> return_i . ;
    ;               shift and go to state 28


state 13

    (14) instruction -> if_i .
    {               reduce using rule 14 (instruction -> if_i .)
    BREAK           reduce using rule 14 (instruction -> if_i .)
    CONTINUE        reduce using rule 14 (instruction -> if_i .)
    PRINT           reduce using rule 14 (instruction -> if_i .)
    WHILE           reduce using rule 14 (instruction -> if_i .)
    FOR             reduce using rule 14 (instruction -> if_i .)
    RETURN          reduce using rule 14 (instruction -> if_i .)
    IF              reduce using rule 14 (instruction -> if_i .)
    ID              reduce using rule 14 (instruction -> if_i .)
    $end            reduce using rule 14 (instruction -> if_i .)
    }               reduce using rule 14 (instruction -> if_i .)
    ELSE            reduce using rule 14 (instruction -> if_i .)


state 14

    (32) print_i -> PRINT . error
    (33) print_i -> PRINT . printargs
    (34) printargs -> . expr
    (35) printargs -> . expr , printargs
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 29
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    printargs                      shift and go to state 30
    expr                           shift and go to state 31
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 15

    (69) assign -> var . DIVIDEASSIGN error
    (70) assign -> var . MULTIPLYASSIGN error
    (71) assign -> var . MINUSASSIGN error
    (72) assign -> var . PLUSASSIGN error
    (73) assign -> var . = error
    (74) assign -> var . DIVIDEASSIGN expr
    (75) assign -> var . MULTIPLYASSIGN expr
    (76) assign -> var . MINUSASSIGN expr
    (77) assign -> var . PLUSASSIGN expr
    (78) assign -> var . = expr
    DIVIDEASSIGN    shift and go to state 46
    MULTIPLYASSIGN  shift and go to state 47
    MINUSASSIGN     shift and go to state 48
    PLUSASSIGN      shift and go to state 49
    =               shift and go to state 50


state 16

    (22) while_l -> WHILE . ( expr ) error
    (23) while_l -> WHILE . ( error ) instruction
    (24) while_l -> WHILE . ( expr ) instruction
    (               shift and go to state 51


state 17

    (25) for_l -> FOR . ID = expr : expr error
    (26) for_l -> FOR . ID = expr : error instruction
    (27) for_l -> FOR . ID = error : expr instruction
    (28) for_l -> FOR . ID = expr : expr instruction
    ID              shift and go to state 52


state 18

    (62) var -> ID .
    (64) matel -> ID . [ mat_ref_args ]
    DIVIDEASSIGN    reduce using rule 62 (var -> ID .)
    MULTIPLYASSIGN  reduce using rule 62 (var -> ID .)
    MINUSASSIGN     reduce using rule 62 (var -> ID .)
    PLUSASSIGN      reduce using rule 62 (var -> ID .)
    =               reduce using rule 62 (var -> ID .)
    ,               reduce using rule 62 (var -> ID .)
    DOTMINUS        reduce using rule 62 (var -> ID .)
    DOTPLUS         reduce using rule 62 (var -> ID .)
    DOTDIVIDE       reduce using rule 62 (var -> ID .)
    DOTMULTIPLY     reduce using rule 62 (var -> ID .)
    OR              reduce using rule 62 (var -> ID .)
    AND             reduce using rule 62 (var -> ID .)
    XOR             reduce using rule 62 (var -> ID .)
    GTE             reduce using rule 62 (var -> ID .)
    LTE             reduce using rule 62 (var -> ID .)
    GT              reduce using rule 62 (var -> ID .)
    LT              reduce using rule 62 (var -> ID .)
    NEQ             reduce using rule 62 (var -> ID .)
    EQ              reduce using rule 62 (var -> ID .)
    /               reduce using rule 62 (var -> ID .)
    *               reduce using rule 62 (var -> ID .)
    -               reduce using rule 62 (var -> ID .)
    +               reduce using rule 62 (var -> ID .)
    '               reduce using rule 62 (var -> ID .)
    ;               reduce using rule 62 (var -> ID .)
    )               reduce using rule 62 (var -> ID .)
    ]               reduce using rule 62 (var -> ID .)
    :               reduce using rule 62 (var -> ID .)
    error           reduce using rule 62 (var -> ID .)
    {               reduce using rule 62 (var -> ID .)
    BREAK           reduce using rule 62 (var -> ID .)
    CONTINUE        reduce using rule 62 (var -> ID .)
    PRINT           reduce using rule 62 (var -> ID .)
    WHILE           reduce using rule 62 (var -> ID .)
    FOR             reduce using rule 62 (var -> ID .)
    RETURN          reduce using rule 62 (var -> ID .)
    IF              reduce using rule 62 (var -> ID .)
    ID              reduce using rule 62 (var -> ID .)
    [               shift and go to state 53


state 19

    (29) return_i -> RETURN . error
    (30) return_i -> RETURN . expr
    (31) return_i -> RETURN .
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 54
    ;               reduce using rule 31 (return_i -> RETURN .)
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 55
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 20

    (15) if_i -> IF . ( expr ) instruction ELSE error
    (16) if_i -> IF . ( expr ) error ELSE instruction
    (17) if_i -> IF . ( expr ) error
    (18) if_i -> IF . ( error ) instruction ELSE instruction
    (19) if_i -> IF . ( error ) instruction
    (20) if_i -> IF . ( expr ) instruction ELSE instruction
    (21) if_i -> IF . ( expr ) instruction
    (               shift and go to state 56


state 21

    (63) var -> matel .
    DIVIDEASSIGN    reduce using rule 63 (var -> matel .)
    MULTIPLYASSIGN  reduce using rule 63 (var -> matel .)
    MINUSASSIGN     reduce using rule 63 (var -> matel .)
    PLUSASSIGN      reduce using rule 63 (var -> matel .)
    =               reduce using rule 63 (var -> matel .)
    ,               reduce using rule 63 (var -> matel .)
    DOTMINUS        reduce using rule 63 (var -> matel .)
    DOTPLUS         reduce using rule 63 (var -> matel .)
    DOTDIVIDE       reduce using rule 63 (var -> matel .)
    DOTMULTIPLY     reduce using rule 63 (var -> matel .)
    OR              reduce using rule 63 (var -> matel .)
    AND             reduce using rule 63 (var -> matel .)
    XOR             reduce using rule 63 (var -> matel .)
    GTE             reduce using rule 63 (var -> matel .)
    LTE             reduce using rule 63 (var -> matel .)
    GT              reduce using rule 63 (var -> matel .)
    LT              reduce using rule 63 (var -> matel .)
    NEQ             reduce using rule 63 (var -> matel .)
    EQ              reduce using rule 63 (var -> matel .)
    /               reduce using rule 63 (var -> matel .)
    *               reduce using rule 63 (var -> matel .)
    -               reduce using rule 63 (var -> matel .)
    +               reduce using rule 63 (var -> matel .)
    '               reduce using rule 63 (var -> matel .)
    ;               reduce using rule 63 (var -> matel .)
    )               reduce using rule 63 (var -> matel .)
    ]               reduce using rule 63 (var -> matel .)
    :               reduce using rule 63 (var -> matel .)
    error           reduce using rule 63 (var -> matel .)
    {               reduce using rule 63 (var -> matel .)
    BREAK           reduce using rule 63 (var -> matel .)
    CONTINUE        reduce using rule 63 (var -> matel .)
    PRINT           reduce using rule 63 (var -> matel .)
    WHILE           reduce using rule 63 (var -> matel .)
    FOR             reduce using rule 63 (var -> matel .)
    RETURN          reduce using rule 63 (var -> matel .)
    IF              reduce using rule 63 (var -> matel .)
    ID              reduce using rule 63 (var -> matel .)


state 22

    (5) instructions -> instructions instruction .
    {               reduce using rule 5 (instructions -> instructions instruction .)
    BREAK           reduce using rule 5 (instructions -> instructions instruction .)
    CONTINUE        reduce using rule 5 (instructions -> instructions instruction .)
    PRINT           reduce using rule 5 (instructions -> instructions instruction .)
    WHILE           reduce using rule 5 (instructions -> instructions instruction .)
    FOR             reduce using rule 5 (instructions -> instructions instruction .)
    RETURN          reduce using rule 5 (instructions -> instructions instruction .)
    IF              reduce using rule 5 (instructions -> instructions instruction .)
    ID              reduce using rule 5 (instructions -> instructions instruction .)
    $end            reduce using rule 5 (instructions -> instructions instruction .)
    }               reduce using rule 5 (instructions -> instructions instruction .)


state 23

    (6) instruction -> { instructions . }
    (5) instructions -> instructions . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    }               shift and go to state 57
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 22
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 24

    (7) instruction -> BREAK ; .
    {               reduce using rule 7 (instruction -> BREAK ; .)
    BREAK           reduce using rule 7 (instruction -> BREAK ; .)
    CONTINUE        reduce using rule 7 (instruction -> BREAK ; .)
    PRINT           reduce using rule 7 (instruction -> BREAK ; .)
    WHILE           reduce using rule 7 (instruction -> BREAK ; .)
    FOR             reduce using rule 7 (instruction -> BREAK ; .)
    RETURN          reduce using rule 7 (instruction -> BREAK ; .)
    IF              reduce using rule 7 (instruction -> BREAK ; .)
    ID              reduce using rule 7 (instruction -> BREAK ; .)
    $end            reduce using rule 7 (instruction -> BREAK ; .)
    }               reduce using rule 7 (instruction -> BREAK ; .)
    ELSE            reduce using rule 7 (instruction -> BREAK ; .)


state 25

    (8) instruction -> CONTINUE ; .
    {               reduce using rule 8 (instruction -> CONTINUE ; .)
    BREAK           reduce using rule 8 (instruction -> CONTINUE ; .)
    CONTINUE        reduce using rule 8 (instruction -> CONTINUE ; .)
    PRINT           reduce using rule 8 (instruction -> CONTINUE ; .)
    WHILE           reduce using rule 8 (instruction -> CONTINUE ; .)
    FOR             reduce using rule 8 (instruction -> CONTINUE ; .)
    RETURN          reduce using rule 8 (instruction -> CONTINUE ; .)
    IF              reduce using rule 8 (instruction -> CONTINUE ; .)
    ID              reduce using rule 8 (instruction -> CONTINUE ; .)
    $end            reduce using rule 8 (instruction -> CONTINUE ; .)
    }               reduce using rule 8 (instruction -> CONTINUE ; .)
    ELSE            reduce using rule 8 (instruction -> CONTINUE ; .)


state 26

    (9) instruction -> print_i ; .
    {               reduce using rule 9 (instruction -> print_i ; .)
    BREAK           reduce using rule 9 (instruction -> print_i ; .)
    CONTINUE        reduce using rule 9 (instruction -> print_i ; .)
    PRINT           reduce using rule 9 (instruction -> print_i ; .)
    WHILE           reduce using rule 9 (instruction -> print_i ; .)
    FOR             reduce using rule 9 (instruction -> print_i ; .)
    RETURN          reduce using rule 9 (instruction -> print_i ; .)
    IF              reduce using rule 9 (instruction -> print_i ; .)
    ID              reduce using rule 9 (instruction -> print_i ; .)
    $end            reduce using rule 9 (instruction -> print_i ; .)
    }               reduce using rule 9 (instruction -> print_i ; .)
    ELSE            reduce using rule 9 (instruction -> print_i ; .)


state 27

    (10) instruction -> assign ; .
    {               reduce using rule 10 (instruction -> assign ; .)
    BREAK           reduce using rule 10 (instruction -> assign ; .)
    CONTINUE        reduce using rule 10 (instruction -> assign ; .)
    PRINT           reduce using rule 10 (instruction -> assign ; .)
    WHILE           reduce using rule 10 (instruction -> assign ; .)
    FOR             reduce using rule 10 (instruction -> assign ; .)
    RETURN          reduce using rule 10 (instruction -> assign ; .)
    IF              reduce using rule 10 (instruction -> assign ; .)
    ID              reduce using rule 10 (instruction -> assign ; .)
    $end            reduce using rule 10 (instruction -> assign ; .)
    }               reduce using rule 10 (instruction -> assign ; .)
    ELSE            reduce using rule 10 (instruction -> assign ; .)


state 28

    (13) instruction -> return_i ; .
    {               reduce using rule 13 (instruction -> return_i ; .)
    BREAK           reduce using rule 13 (instruction -> return_i ; .)
    CONTINUE        reduce using rule 13 (instruction -> return_i ; .)
    PRINT           reduce using rule 13 (instruction -> return_i ; .)
    WHILE           reduce using rule 13 (instruction -> return_i ; .)
    FOR             reduce using rule 13 (instruction -> return_i ; .)
    RETURN          reduce using rule 13 (instruction -> return_i ; .)
    IF              reduce using rule 13 (instruction -> return_i ; .)
    ID              reduce using rule 13 (instruction -> return_i ; .)
    $end            reduce using rule 13 (instruction -> return_i ; .)
    }               reduce using rule 13 (instruction -> return_i ; .)
    ELSE            reduce using rule 13 (instruction -> return_i ; .)


state 29

    (32) print_i -> PRINT error .
    ;               reduce using rule 32 (print_i -> PRINT error .)


state 30

    (33) print_i -> PRINT printargs .
    ;               reduce using rule 33 (print_i -> PRINT printargs .)


state 31

    (34) printargs -> expr .
    (35) printargs -> expr . , printargs
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ;               reduce using rule 34 (printargs -> expr .)
    ,               shift and go to state 58
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 32

    (36) expr -> mat_fun . ( error )
    (37) expr -> mat_fun . ( mat_fun_args )
    (               shift and go to state 77


state 33

    (57) expr -> ( . expr )
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 78
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 34

    (38) expr -> vector .
    ,               reduce using rule 38 (expr -> vector .)
    DOTMINUS        reduce using rule 38 (expr -> vector .)
    DOTPLUS         reduce using rule 38 (expr -> vector .)
    DOTDIVIDE       reduce using rule 38 (expr -> vector .)
    DOTMULTIPLY     reduce using rule 38 (expr -> vector .)
    OR              reduce using rule 38 (expr -> vector .)
    AND             reduce using rule 38 (expr -> vector .)
    XOR             reduce using rule 38 (expr -> vector .)
    GTE             reduce using rule 38 (expr -> vector .)
    LTE             reduce using rule 38 (expr -> vector .)
    GT              reduce using rule 38 (expr -> vector .)
    LT              reduce using rule 38 (expr -> vector .)
    NEQ             reduce using rule 38 (expr -> vector .)
    EQ              reduce using rule 38 (expr -> vector .)
    /               reduce using rule 38 (expr -> vector .)
    *               reduce using rule 38 (expr -> vector .)
    -               reduce using rule 38 (expr -> vector .)
    +               reduce using rule 38 (expr -> vector .)
    '               reduce using rule 38 (expr -> vector .)
    ;               reduce using rule 38 (expr -> vector .)
    )               reduce using rule 38 (expr -> vector .)
    ]               reduce using rule 38 (expr -> vector .)
    :               reduce using rule 38 (expr -> vector .)
    error           reduce using rule 38 (expr -> vector .)
    {               reduce using rule 38 (expr -> vector .)
    BREAK           reduce using rule 38 (expr -> vector .)
    CONTINUE        reduce using rule 38 (expr -> vector .)
    PRINT           reduce using rule 38 (expr -> vector .)
    WHILE           reduce using rule 38 (expr -> vector .)
    FOR             reduce using rule 38 (expr -> vector .)
    RETURN          reduce using rule 38 (expr -> vector .)
    IF              reduce using rule 38 (expr -> vector .)
    ID              reduce using rule 38 (expr -> vector .)


state 35

    (81) unary -> - . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 79
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 36

    (56) expr -> unary .
    ,               reduce using rule 56 (expr -> unary .)
    DOTMINUS        reduce using rule 56 (expr -> unary .)
    DOTPLUS         reduce using rule 56 (expr -> unary .)
    DOTDIVIDE       reduce using rule 56 (expr -> unary .)
    DOTMULTIPLY     reduce using rule 56 (expr -> unary .)
    OR              reduce using rule 56 (expr -> unary .)
    AND             reduce using rule 56 (expr -> unary .)
    XOR             reduce using rule 56 (expr -> unary .)
    GTE             reduce using rule 56 (expr -> unary .)
    LTE             reduce using rule 56 (expr -> unary .)
    GT              reduce using rule 56 (expr -> unary .)
    LT              reduce using rule 56 (expr -> unary .)
    NEQ             reduce using rule 56 (expr -> unary .)
    EQ              reduce using rule 56 (expr -> unary .)
    /               reduce using rule 56 (expr -> unary .)
    *               reduce using rule 56 (expr -> unary .)
    -               reduce using rule 56 (expr -> unary .)
    +               reduce using rule 56 (expr -> unary .)
    '               reduce using rule 56 (expr -> unary .)
    ;               reduce using rule 56 (expr -> unary .)
    )               reduce using rule 56 (expr -> unary .)
    ]               reduce using rule 56 (expr -> unary .)
    :               reduce using rule 56 (expr -> unary .)
    error           reduce using rule 56 (expr -> unary .)
    {               reduce using rule 56 (expr -> unary .)
    BREAK           reduce using rule 56 (expr -> unary .)
    CONTINUE        reduce using rule 56 (expr -> unary .)
    PRINT           reduce using rule 56 (expr -> unary .)
    WHILE           reduce using rule 56 (expr -> unary .)
    FOR             reduce using rule 56 (expr -> unary .)
    RETURN          reduce using rule 56 (expr -> unary .)
    IF              reduce using rule 56 (expr -> unary .)
    ID              reduce using rule 56 (expr -> unary .)


state 37

    (58) expr -> var .
    ,               reduce using rule 58 (expr -> var .)
    DOTMINUS        reduce using rule 58 (expr -> var .)
    DOTPLUS         reduce using rule 58 (expr -> var .)
    DOTDIVIDE       reduce using rule 58 (expr -> var .)
    DOTMULTIPLY     reduce using rule 58 (expr -> var .)
    OR              reduce using rule 58 (expr -> var .)
    AND             reduce using rule 58 (expr -> var .)
    XOR             reduce using rule 58 (expr -> var .)
    GTE             reduce using rule 58 (expr -> var .)
    LTE             reduce using rule 58 (expr -> var .)
    GT              reduce using rule 58 (expr -> var .)
    LT              reduce using rule 58 (expr -> var .)
    NEQ             reduce using rule 58 (expr -> var .)
    EQ              reduce using rule 58 (expr -> var .)
    /               reduce using rule 58 (expr -> var .)
    *               reduce using rule 58 (expr -> var .)
    -               reduce using rule 58 (expr -> var .)
    +               reduce using rule 58 (expr -> var .)
    '               reduce using rule 58 (expr -> var .)
    ;               reduce using rule 58 (expr -> var .)
    )               reduce using rule 58 (expr -> var .)
    ]               reduce using rule 58 (expr -> var .)
    :               reduce using rule 58 (expr -> var .)
    error           reduce using rule 58 (expr -> var .)
    {               reduce using rule 58 (expr -> var .)
    BREAK           reduce using rule 58 (expr -> var .)
    CONTINUE        reduce using rule 58 (expr -> var .)
    PRINT           reduce using rule 58 (expr -> var .)
    WHILE           reduce using rule 58 (expr -> var .)
    FOR             reduce using rule 58 (expr -> var .)
    RETURN          reduce using rule 58 (expr -> var .)
    IF              reduce using rule 58 (expr -> var .)
    ID              reduce using rule 58 (expr -> var .)


state 38

    (59) expr -> FLOATNUM .
    ,               reduce using rule 59 (expr -> FLOATNUM .)
    DOTMINUS        reduce using rule 59 (expr -> FLOATNUM .)
    DOTPLUS         reduce using rule 59 (expr -> FLOATNUM .)
    DOTDIVIDE       reduce using rule 59 (expr -> FLOATNUM .)
    DOTMULTIPLY     reduce using rule 59 (expr -> FLOATNUM .)
    OR              reduce using rule 59 (expr -> FLOATNUM .)
    AND             reduce using rule 59 (expr -> FLOATNUM .)
    XOR             reduce using rule 59 (expr -> FLOATNUM .)
    GTE             reduce using rule 59 (expr -> FLOATNUM .)
    LTE             reduce using rule 59 (expr -> FLOATNUM .)
    GT              reduce using rule 59 (expr -> FLOATNUM .)
    LT              reduce using rule 59 (expr -> FLOATNUM .)
    NEQ             reduce using rule 59 (expr -> FLOATNUM .)
    EQ              reduce using rule 59 (expr -> FLOATNUM .)
    /               reduce using rule 59 (expr -> FLOATNUM .)
    *               reduce using rule 59 (expr -> FLOATNUM .)
    -               reduce using rule 59 (expr -> FLOATNUM .)
    +               reduce using rule 59 (expr -> FLOATNUM .)
    '               reduce using rule 59 (expr -> FLOATNUM .)
    ;               reduce using rule 59 (expr -> FLOATNUM .)
    )               reduce using rule 59 (expr -> FLOATNUM .)
    ]               reduce using rule 59 (expr -> FLOATNUM .)
    :               reduce using rule 59 (expr -> FLOATNUM .)
    error           reduce using rule 59 (expr -> FLOATNUM .)
    {               reduce using rule 59 (expr -> FLOATNUM .)
    BREAK           reduce using rule 59 (expr -> FLOATNUM .)
    CONTINUE        reduce using rule 59 (expr -> FLOATNUM .)
    PRINT           reduce using rule 59 (expr -> FLOATNUM .)
    WHILE           reduce using rule 59 (expr -> FLOATNUM .)
    FOR             reduce using rule 59 (expr -> FLOATNUM .)
    RETURN          reduce using rule 59 (expr -> FLOATNUM .)
    IF              reduce using rule 59 (expr -> FLOATNUM .)
    ID              reduce using rule 59 (expr -> FLOATNUM .)


state 39

    (60) expr -> INTNUM .
    ,               reduce using rule 60 (expr -> INTNUM .)
    DOTMINUS        reduce using rule 60 (expr -> INTNUM .)
    DOTPLUS         reduce using rule 60 (expr -> INTNUM .)
    DOTDIVIDE       reduce using rule 60 (expr -> INTNUM .)
    DOTMULTIPLY     reduce using rule 60 (expr -> INTNUM .)
    OR              reduce using rule 60 (expr -> INTNUM .)
    AND             reduce using rule 60 (expr -> INTNUM .)
    XOR             reduce using rule 60 (expr -> INTNUM .)
    GTE             reduce using rule 60 (expr -> INTNUM .)
    LTE             reduce using rule 60 (expr -> INTNUM .)
    GT              reduce using rule 60 (expr -> INTNUM .)
    LT              reduce using rule 60 (expr -> INTNUM .)
    NEQ             reduce using rule 60 (expr -> INTNUM .)
    EQ              reduce using rule 60 (expr -> INTNUM .)
    /               reduce using rule 60 (expr -> INTNUM .)
    *               reduce using rule 60 (expr -> INTNUM .)
    -               reduce using rule 60 (expr -> INTNUM .)
    +               reduce using rule 60 (expr -> INTNUM .)
    '               reduce using rule 60 (expr -> INTNUM .)
    ;               reduce using rule 60 (expr -> INTNUM .)
    )               reduce using rule 60 (expr -> INTNUM .)
    ]               reduce using rule 60 (expr -> INTNUM .)
    :               reduce using rule 60 (expr -> INTNUM .)
    error           reduce using rule 60 (expr -> INTNUM .)
    {               reduce using rule 60 (expr -> INTNUM .)
    BREAK           reduce using rule 60 (expr -> INTNUM .)
    CONTINUE        reduce using rule 60 (expr -> INTNUM .)
    PRINT           reduce using rule 60 (expr -> INTNUM .)
    WHILE           reduce using rule 60 (expr -> INTNUM .)
    FOR             reduce using rule 60 (expr -> INTNUM .)
    RETURN          reduce using rule 60 (expr -> INTNUM .)
    IF              reduce using rule 60 (expr -> INTNUM .)
    ID              reduce using rule 60 (expr -> INTNUM .)


state 40

    (61) expr -> STRING .
    ,               reduce using rule 61 (expr -> STRING .)
    DOTMINUS        reduce using rule 61 (expr -> STRING .)
    DOTPLUS         reduce using rule 61 (expr -> STRING .)
    DOTDIVIDE       reduce using rule 61 (expr -> STRING .)
    DOTMULTIPLY     reduce using rule 61 (expr -> STRING .)
    OR              reduce using rule 61 (expr -> STRING .)
    AND             reduce using rule 61 (expr -> STRING .)
    XOR             reduce using rule 61 (expr -> STRING .)
    GTE             reduce using rule 61 (expr -> STRING .)
    LTE             reduce using rule 61 (expr -> STRING .)
    GT              reduce using rule 61 (expr -> STRING .)
    LT              reduce using rule 61 (expr -> STRING .)
    NEQ             reduce using rule 61 (expr -> STRING .)
    EQ              reduce using rule 61 (expr -> STRING .)
    /               reduce using rule 61 (expr -> STRING .)
    *               reduce using rule 61 (expr -> STRING .)
    -               reduce using rule 61 (expr -> STRING .)
    +               reduce using rule 61 (expr -> STRING .)
    '               reduce using rule 61 (expr -> STRING .)
    ;               reduce using rule 61 (expr -> STRING .)
    )               reduce using rule 61 (expr -> STRING .)
    ]               reduce using rule 61 (expr -> STRING .)
    :               reduce using rule 61 (expr -> STRING .)
    error           reduce using rule 61 (expr -> STRING .)
    {               reduce using rule 61 (expr -> STRING .)
    BREAK           reduce using rule 61 (expr -> STRING .)
    CONTINUE        reduce using rule 61 (expr -> STRING .)
    PRINT           reduce using rule 61 (expr -> STRING .)
    WHILE           reduce using rule 61 (expr -> STRING .)
    FOR             reduce using rule 61 (expr -> STRING .)
    RETURN          reduce using rule 61 (expr -> STRING .)
    IF              reduce using rule 61 (expr -> STRING .)
    ID              reduce using rule 61 (expr -> STRING .)


state 41

    (87) mat_fun -> ONES .
    (               reduce using rule 87 (mat_fun -> ONES .)


state 42

    (88) mat_fun -> EYE .
    (               reduce using rule 88 (mat_fun -> EYE .)


state 43

    (89) mat_fun -> ZEROS .
    (               reduce using rule 89 (mat_fun -> ZEROS .)


state 44

    (82) vector -> [ . variables ]
    (83) variables -> . expr
    (84) variables -> . variables , expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    variables                      shift and go to state 80
    expr                           shift and go to state 81
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 45

    (80) unary -> NOT . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 82
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 46

    (69) assign -> var DIVIDEASSIGN . error
    (74) assign -> var DIVIDEASSIGN . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 83
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    var                            shift and go to state 37
    expr                           shift and go to state 84
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    matel                          shift and go to state 21

state 47

    (70) assign -> var MULTIPLYASSIGN . error
    (75) assign -> var MULTIPLYASSIGN . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 85
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    var                            shift and go to state 37
    expr                           shift and go to state 86
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    matel                          shift and go to state 21

state 48

    (71) assign -> var MINUSASSIGN . error
    (76) assign -> var MINUSASSIGN . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 87
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    var                            shift and go to state 37
    expr                           shift and go to state 88
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    matel                          shift and go to state 21

state 49

    (72) assign -> var PLUSASSIGN . error
    (77) assign -> var PLUSASSIGN . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 89
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    var                            shift and go to state 37
    expr                           shift and go to state 90
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    matel                          shift and go to state 21

state 50

    (73) assign -> var = . error
    (78) assign -> var = . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 91
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    var                            shift and go to state 37
    expr                           shift and go to state 92
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    matel                          shift and go to state 21

state 51

    (22) while_l -> WHILE ( . expr ) error
    (23) while_l -> WHILE ( . error ) instruction
    (24) while_l -> WHILE ( . expr ) instruction
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 94
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 93
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 52

    (25) for_l -> FOR ID . = expr : expr error
    (26) for_l -> FOR ID . = expr : error instruction
    (27) for_l -> FOR ID . = error : expr instruction
    (28) for_l -> FOR ID . = expr : expr instruction
    =               shift and go to state 95


state 53

    (64) matel -> ID [ . mat_ref_args ]
    (65) mat_ref_args -> . expr : expr
    (66) mat_ref_args -> . mat_ref_args , expr : expr
    (67) mat_ref_args -> . expr
    (68) mat_ref_args -> . mat_ref_args , expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    mat_ref_args                   shift and go to state 96
    expr                           shift and go to state 97
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 54

    (29) return_i -> RETURN error .
    ;               reduce using rule 29 (return_i -> RETURN error .)


state 55

    (30) return_i -> RETURN expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ;               reduce using rule 30 (return_i -> RETURN expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 56

    (15) if_i -> IF ( . expr ) instruction ELSE error
    (16) if_i -> IF ( . expr ) error ELSE instruction
    (17) if_i -> IF ( . expr ) error
    (18) if_i -> IF ( . error ) instruction ELSE instruction
    (19) if_i -> IF ( . error ) instruction
    (20) if_i -> IF ( . expr ) instruction ELSE instruction
    (21) if_i -> IF ( . expr ) instruction
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 99
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 98
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 57

    (6) instruction -> { instructions } .
    {               reduce using rule 6 (instruction -> { instructions } .)
    BREAK           reduce using rule 6 (instruction -> { instructions } .)
    CONTINUE        reduce using rule 6 (instruction -> { instructions } .)
    PRINT           reduce using rule 6 (instruction -> { instructions } .)
    WHILE           reduce using rule 6 (instruction -> { instructions } .)
    FOR             reduce using rule 6 (instruction -> { instructions } .)
    RETURN          reduce using rule 6 (instruction -> { instructions } .)
    IF              reduce using rule 6 (instruction -> { instructions } .)
    ID              reduce using rule 6 (instruction -> { instructions } .)
    $end            reduce using rule 6 (instruction -> { instructions } .)
    }               reduce using rule 6 (instruction -> { instructions } .)
    ELSE            reduce using rule 6 (instruction -> { instructions } .)


state 58

    (35) printargs -> expr , . printargs
    (34) printargs -> . expr
    (35) printargs -> . expr , printargs
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 31
    printargs                      shift and go to state 100
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 59

    (39) expr -> expr DOTMINUS . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 101
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 60

    (40) expr -> expr DOTPLUS . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 102
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 61

    (41) expr -> expr DOTDIVIDE . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 103
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 62

    (42) expr -> expr DOTMULTIPLY . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 104
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 63

    (43) expr -> expr OR . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 105
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 64

    (44) expr -> expr AND . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 106
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 65

    (45) expr -> expr XOR . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 107
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 66

    (46) expr -> expr GTE . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 108
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 67

    (47) expr -> expr LTE . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 109
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 68

    (48) expr -> expr GT . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 110
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 69

    (49) expr -> expr LT . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 111
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 70

    (50) expr -> expr NEQ . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 112
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 71

    (51) expr -> expr EQ . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 113
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 72

    (52) expr -> expr / . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 114
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 73

    (53) expr -> expr * . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 115
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 74

    (54) expr -> expr - . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 116
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 75

    (55) expr -> expr + . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 117
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 76

    (79) unary -> expr ' .
    ,               reduce using rule 79 (unary -> expr ' .)
    DOTMINUS        reduce using rule 79 (unary -> expr ' .)
    DOTPLUS         reduce using rule 79 (unary -> expr ' .)
    DOTDIVIDE       reduce using rule 79 (unary -> expr ' .)
    DOTMULTIPLY     reduce using rule 79 (unary -> expr ' .)
    OR              reduce using rule 79 (unary -> expr ' .)
    AND             reduce using rule 79 (unary -> expr ' .)
    XOR             reduce using rule 79 (unary -> expr ' .)
    GTE             reduce using rule 79 (unary -> expr ' .)
    LTE             reduce using rule 79 (unary -> expr ' .)
    GT              reduce using rule 79 (unary -> expr ' .)
    LT              reduce using rule 79 (unary -> expr ' .)
    NEQ             reduce using rule 79 (unary -> expr ' .)
    EQ              reduce using rule 79 (unary -> expr ' .)
    /               reduce using rule 79 (unary -> expr ' .)
    *               reduce using rule 79 (unary -> expr ' .)
    -               reduce using rule 79 (unary -> expr ' .)
    +               reduce using rule 79 (unary -> expr ' .)
    '               reduce using rule 79 (unary -> expr ' .)
    ;               reduce using rule 79 (unary -> expr ' .)
    )               reduce using rule 79 (unary -> expr ' .)
    ]               reduce using rule 79 (unary -> expr ' .)
    :               reduce using rule 79 (unary -> expr ' .)
    error           reduce using rule 79 (unary -> expr ' .)
    {               reduce using rule 79 (unary -> expr ' .)
    BREAK           reduce using rule 79 (unary -> expr ' .)
    CONTINUE        reduce using rule 79 (unary -> expr ' .)
    PRINT           reduce using rule 79 (unary -> expr ' .)
    WHILE           reduce using rule 79 (unary -> expr ' .)
    FOR             reduce using rule 79 (unary -> expr ' .)
    RETURN          reduce using rule 79 (unary -> expr ' .)
    IF              reduce using rule 79 (unary -> expr ' .)
    ID              reduce using rule 79 (unary -> expr ' .)


state 77

    (36) expr -> mat_fun ( . error )
    (37) expr -> mat_fun ( . mat_fun_args )
    (85) mat_fun_args -> . expr
    (86) mat_fun_args -> . mat_fun_args , expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 118
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    mat_fun                        shift and go to state 32
    mat_fun_args                   shift and go to state 119
    expr                           shift and go to state 120
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 78

    (57) expr -> ( expr . )
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    )               shift and go to state 121
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 79

    (81) unary -> - expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 81 (unary -> - expr .)
    DOTMINUS        reduce using rule 81 (unary -> - expr .)
    DOTPLUS         reduce using rule 81 (unary -> - expr .)
    DOTDIVIDE       reduce using rule 81 (unary -> - expr .)
    DOTMULTIPLY     reduce using rule 81 (unary -> - expr .)
    OR              reduce using rule 81 (unary -> - expr .)
    AND             reduce using rule 81 (unary -> - expr .)
    XOR             reduce using rule 81 (unary -> - expr .)
    GTE             reduce using rule 81 (unary -> - expr .)
    LTE             reduce using rule 81 (unary -> - expr .)
    GT              reduce using rule 81 (unary -> - expr .)
    LT              reduce using rule 81 (unary -> - expr .)
    NEQ             reduce using rule 81 (unary -> - expr .)
    EQ              reduce using rule 81 (unary -> - expr .)
    /               reduce using rule 81 (unary -> - expr .)
    *               reduce using rule 81 (unary -> - expr .)
    -               reduce using rule 81 (unary -> - expr .)
    +               reduce using rule 81 (unary -> - expr .)
    '               reduce using rule 81 (unary -> - expr .)
    ;               reduce using rule 81 (unary -> - expr .)
    )               reduce using rule 81 (unary -> - expr .)
    ]               reduce using rule 81 (unary -> - expr .)
    :               reduce using rule 81 (unary -> - expr .)
    error           reduce using rule 81 (unary -> - expr .)
    {               reduce using rule 81 (unary -> - expr .)
    BREAK           reduce using rule 81 (unary -> - expr .)
    CONTINUE        reduce using rule 81 (unary -> - expr .)
    PRINT           reduce using rule 81 (unary -> - expr .)
    WHILE           reduce using rule 81 (unary -> - expr .)
    FOR             reduce using rule 81 (unary -> - expr .)
    RETURN          reduce using rule 81 (unary -> - expr .)
    IF              reduce using rule 81 (unary -> - expr .)
    ID              reduce using rule 81 (unary -> - expr .)


state 80

    (82) vector -> [ variables . ]
    (84) variables -> variables . , expr
    ]               shift and go to state 122
    ,               shift and go to state 123


state 81

    (83) variables -> expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ]               reduce using rule 83 (variables -> expr .)
    ,               reduce using rule 83 (variables -> expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 82

    (80) unary -> NOT expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 80 (unary -> NOT expr .)
    DOTMINUS        reduce using rule 80 (unary -> NOT expr .)
    DOTPLUS         reduce using rule 80 (unary -> NOT expr .)
    DOTDIVIDE       reduce using rule 80 (unary -> NOT expr .)
    DOTMULTIPLY     reduce using rule 80 (unary -> NOT expr .)
    OR              reduce using rule 80 (unary -> NOT expr .)
    AND             reduce using rule 80 (unary -> NOT expr .)
    XOR             reduce using rule 80 (unary -> NOT expr .)
    GTE             reduce using rule 80 (unary -> NOT expr .)
    LTE             reduce using rule 80 (unary -> NOT expr .)
    GT              reduce using rule 80 (unary -> NOT expr .)
    LT              reduce using rule 80 (unary -> NOT expr .)
    NEQ             reduce using rule 80 (unary -> NOT expr .)
    EQ              reduce using rule 80 (unary -> NOT expr .)
    /               reduce using rule 80 (unary -> NOT expr .)
    *               reduce using rule 80 (unary -> NOT expr .)
    -               reduce using rule 80 (unary -> NOT expr .)
    +               reduce using rule 80 (unary -> NOT expr .)
    '               reduce using rule 80 (unary -> NOT expr .)
    ;               reduce using rule 80 (unary -> NOT expr .)
    )               reduce using rule 80 (unary -> NOT expr .)
    ]               reduce using rule 80 (unary -> NOT expr .)
    :               reduce using rule 80 (unary -> NOT expr .)
    error           reduce using rule 80 (unary -> NOT expr .)
    {               reduce using rule 80 (unary -> NOT expr .)
    BREAK           reduce using rule 80 (unary -> NOT expr .)
    CONTINUE        reduce using rule 80 (unary -> NOT expr .)
    PRINT           reduce using rule 80 (unary -> NOT expr .)
    WHILE           reduce using rule 80 (unary -> NOT expr .)
    FOR             reduce using rule 80 (unary -> NOT expr .)
    RETURN          reduce using rule 80 (unary -> NOT expr .)
    IF              reduce using rule 80 (unary -> NOT expr .)
    ID              reduce using rule 80 (unary -> NOT expr .)


state 83

    (69) assign -> var DIVIDEASSIGN error .
    ;               reduce using rule 69 (assign -> var DIVIDEASSIGN error .)


state 84

    (74) assign -> var DIVIDEASSIGN expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ;               reduce using rule 74 (assign -> var DIVIDEASSIGN expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 85

    (70) assign -> var MULTIPLYASSIGN error .
    ;               reduce using rule 70 (assign -> var MULTIPLYASSIGN error .)


state 86

    (75) assign -> var MULTIPLYASSIGN expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ;               reduce using rule 75 (assign -> var MULTIPLYASSIGN expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 87

    (71) assign -> var MINUSASSIGN error .
    ;               reduce using rule 71 (assign -> var MINUSASSIGN error .)


state 88

    (76) assign -> var MINUSASSIGN expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ;               reduce using rule 76 (assign -> var MINUSASSIGN expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 89

    (72) assign -> var PLUSASSIGN error .
    ;               reduce using rule 72 (assign -> var PLUSASSIGN error .)


state 90

    (77) assign -> var PLUSASSIGN expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ;               reduce using rule 77 (assign -> var PLUSASSIGN expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 91

    (73) assign -> var = error .
    ;               reduce using rule 73 (assign -> var = error .)


state 92

    (78) assign -> var = expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ;               reduce using rule 78 (assign -> var = expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 93

    (22) while_l -> WHILE ( expr . ) error
    (24) while_l -> WHILE ( expr . ) instruction
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    )               shift and go to state 124
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 94

    (23) while_l -> WHILE ( error . ) instruction
    )               shift and go to state 125


state 95

    (25) for_l -> FOR ID = . expr : expr error
    (26) for_l -> FOR ID = . expr : error instruction
    (27) for_l -> FOR ID = . error : expr instruction
    (28) for_l -> FOR ID = . expr : expr instruction
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 127
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 126
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 96

    (64) matel -> ID [ mat_ref_args . ]
    (66) mat_ref_args -> mat_ref_args . , expr : expr
    (68) mat_ref_args -> mat_ref_args . , expr
    ]               shift and go to state 128
    ,               shift and go to state 129


state 97

    (65) mat_ref_args -> expr . : expr
    (67) mat_ref_args -> expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    :               shift and go to state 130
    ]               reduce using rule 67 (mat_ref_args -> expr .)
    ,               reduce using rule 67 (mat_ref_args -> expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 98

    (15) if_i -> IF ( expr . ) instruction ELSE error
    (16) if_i -> IF ( expr . ) error ELSE instruction
    (17) if_i -> IF ( expr . ) error
    (20) if_i -> IF ( expr . ) instruction ELSE instruction
    (21) if_i -> IF ( expr . ) instruction
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    )               shift and go to state 131
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 99

    (18) if_i -> IF ( error . ) instruction ELSE instruction
    (19) if_i -> IF ( error . ) instruction
    )               shift and go to state 132


state 100

    (35) printargs -> expr , printargs .
    ;               reduce using rule 35 (printargs -> expr , printargs .)


state 101

    (39) expr -> expr DOTMINUS expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 39 (expr -> expr DOTMINUS expr .)
    DOTMINUS        reduce using rule 39 (expr -> expr DOTMINUS expr .)
    DOTPLUS         reduce using rule 39 (expr -> expr DOTMINUS expr .)
    OR              reduce using rule 39 (expr -> expr DOTMINUS expr .)
    AND             reduce using rule 39 (expr -> expr DOTMINUS expr .)
    XOR             reduce using rule 39 (expr -> expr DOTMINUS expr .)
    /               reduce using rule 39 (expr -> expr DOTMINUS expr .)
    *               reduce using rule 39 (expr -> expr DOTMINUS expr .)
    -               reduce using rule 39 (expr -> expr DOTMINUS expr .)
    +               reduce using rule 39 (expr -> expr DOTMINUS expr .)
    ;               reduce using rule 39 (expr -> expr DOTMINUS expr .)
    )               reduce using rule 39 (expr -> expr DOTMINUS expr .)
    ]               reduce using rule 39 (expr -> expr DOTMINUS expr .)
    :               reduce using rule 39 (expr -> expr DOTMINUS expr .)
    error           reduce using rule 39 (expr -> expr DOTMINUS expr .)
    {               reduce using rule 39 (expr -> expr DOTMINUS expr .)
    BREAK           reduce using rule 39 (expr -> expr DOTMINUS expr .)
    CONTINUE        reduce using rule 39 (expr -> expr DOTMINUS expr .)
    PRINT           reduce using rule 39 (expr -> expr DOTMINUS expr .)
    WHILE           reduce using rule 39 (expr -> expr DOTMINUS expr .)
    FOR             reduce using rule 39 (expr -> expr DOTMINUS expr .)
    RETURN          reduce using rule 39 (expr -> expr DOTMINUS expr .)
    IF              reduce using rule 39 (expr -> expr DOTMINUS expr .)
    ID              reduce using rule 39 (expr -> expr DOTMINUS expr .)
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    '               shift and go to state 76


state 102

    (40) expr -> expr DOTPLUS expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 40 (expr -> expr DOTPLUS expr .)
    DOTMINUS        reduce using rule 40 (expr -> expr DOTPLUS expr .)
    DOTPLUS         reduce using rule 40 (expr -> expr DOTPLUS expr .)
    OR              reduce using rule 40 (expr -> expr DOTPLUS expr .)
    AND             reduce using rule 40 (expr -> expr DOTPLUS expr .)
    XOR             reduce using rule 40 (expr -> expr DOTPLUS expr .)
    /               reduce using rule 40 (expr -> expr DOTPLUS expr .)
    *               reduce using rule 40 (expr -> expr DOTPLUS expr .)
    -               reduce using rule 40 (expr -> expr DOTPLUS expr .)
    +               reduce using rule 40 (expr -> expr DOTPLUS expr .)
    ;               reduce using rule 40 (expr -> expr DOTPLUS expr .)
    )               reduce using rule 40 (expr -> expr DOTPLUS expr .)
    ]               reduce using rule 40 (expr -> expr DOTPLUS expr .)
    :               reduce using rule 40 (expr -> expr DOTPLUS expr .)
    error           reduce using rule 40 (expr -> expr DOTPLUS expr .)
    {               reduce using rule 40 (expr -> expr DOTPLUS expr .)
    BREAK           reduce using rule 40 (expr -> expr DOTPLUS expr .)
    CONTINUE        reduce using rule 40 (expr -> expr DOTPLUS expr .)
    PRINT           reduce using rule 40 (expr -> expr DOTPLUS expr .)
    WHILE           reduce using rule 40 (expr -> expr DOTPLUS expr .)
    FOR             reduce using rule 40 (expr -> expr DOTPLUS expr .)
    RETURN          reduce using rule 40 (expr -> expr DOTPLUS expr .)
    IF              reduce using rule 40 (expr -> expr DOTPLUS expr .)
    ID              reduce using rule 40 (expr -> expr DOTPLUS expr .)
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    '               shift and go to state 76


state 103

    (41) expr -> expr DOTDIVIDE expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    DOTMINUS        reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    DOTPLUS         reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    DOTDIVIDE       reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    DOTMULTIPLY     reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    OR              reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    AND             reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    XOR             reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    /               reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    *               reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    -               reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    +               reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    ;               reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    )               reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    ]               reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    :               reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    error           reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    {               reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    BREAK           reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    CONTINUE        reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    PRINT           reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    WHILE           reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    FOR             reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    RETURN          reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    IF              reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    ID              reduce using rule 41 (expr -> expr DOTDIVIDE expr .)
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    '               shift and go to state 76


state 104

    (42) expr -> expr DOTMULTIPLY expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    DOTMINUS        reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    DOTPLUS         reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    DOTDIVIDE       reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    DOTMULTIPLY     reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    OR              reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    AND             reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    XOR             reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    /               reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    *               reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    -               reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    +               reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    ;               reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    )               reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    ]               reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    :               reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    error           reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    {               reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    BREAK           reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    CONTINUE        reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    PRINT           reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    WHILE           reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    FOR             reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    RETURN          reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    IF              reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    ID              reduce using rule 42 (expr -> expr DOTMULTIPLY expr .)
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    '               shift and go to state 76


state 105

    (43) expr -> expr OR expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 43 (expr -> expr OR expr .)
    OR              reduce using rule 43 (expr -> expr OR expr .)
    AND             reduce using rule 43 (expr -> expr OR expr .)
    XOR             reduce using rule 43 (expr -> expr OR expr .)
    ;               reduce using rule 43 (expr -> expr OR expr .)
    )               reduce using rule 43 (expr -> expr OR expr .)
    ]               reduce using rule 43 (expr -> expr OR expr .)
    :               reduce using rule 43 (expr -> expr OR expr .)
    error           reduce using rule 43 (expr -> expr OR expr .)
    {               reduce using rule 43 (expr -> expr OR expr .)
    BREAK           reduce using rule 43 (expr -> expr OR expr .)
    CONTINUE        reduce using rule 43 (expr -> expr OR expr .)
    PRINT           reduce using rule 43 (expr -> expr OR expr .)
    WHILE           reduce using rule 43 (expr -> expr OR expr .)
    FOR             reduce using rule 43 (expr -> expr OR expr .)
    RETURN          reduce using rule 43 (expr -> expr OR expr .)
    IF              reduce using rule 43 (expr -> expr OR expr .)
    ID              reduce using rule 43 (expr -> expr OR expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 106

    (44) expr -> expr AND expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 44 (expr -> expr AND expr .)
    OR              reduce using rule 44 (expr -> expr AND expr .)
    AND             reduce using rule 44 (expr -> expr AND expr .)
    XOR             reduce using rule 44 (expr -> expr AND expr .)
    ;               reduce using rule 44 (expr -> expr AND expr .)
    )               reduce using rule 44 (expr -> expr AND expr .)
    ]               reduce using rule 44 (expr -> expr AND expr .)
    :               reduce using rule 44 (expr -> expr AND expr .)
    error           reduce using rule 44 (expr -> expr AND expr .)
    {               reduce using rule 44 (expr -> expr AND expr .)
    BREAK           reduce using rule 44 (expr -> expr AND expr .)
    CONTINUE        reduce using rule 44 (expr -> expr AND expr .)
    PRINT           reduce using rule 44 (expr -> expr AND expr .)
    WHILE           reduce using rule 44 (expr -> expr AND expr .)
    FOR             reduce using rule 44 (expr -> expr AND expr .)
    RETURN          reduce using rule 44 (expr -> expr AND expr .)
    IF              reduce using rule 44 (expr -> expr AND expr .)
    ID              reduce using rule 44 (expr -> expr AND expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 107

    (45) expr -> expr XOR expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 45 (expr -> expr XOR expr .)
    OR              reduce using rule 45 (expr -> expr XOR expr .)
    AND             reduce using rule 45 (expr -> expr XOR expr .)
    XOR             reduce using rule 45 (expr -> expr XOR expr .)
    ;               reduce using rule 45 (expr -> expr XOR expr .)
    )               reduce using rule 45 (expr -> expr XOR expr .)
    ]               reduce using rule 45 (expr -> expr XOR expr .)
    :               reduce using rule 45 (expr -> expr XOR expr .)
    error           reduce using rule 45 (expr -> expr XOR expr .)
    {               reduce using rule 45 (expr -> expr XOR expr .)
    BREAK           reduce using rule 45 (expr -> expr XOR expr .)
    CONTINUE        reduce using rule 45 (expr -> expr XOR expr .)
    PRINT           reduce using rule 45 (expr -> expr XOR expr .)
    WHILE           reduce using rule 45 (expr -> expr XOR expr .)
    FOR             reduce using rule 45 (expr -> expr XOR expr .)
    RETURN          reduce using rule 45 (expr -> expr XOR expr .)
    IF              reduce using rule 45 (expr -> expr XOR expr .)
    ID              reduce using rule 45 (expr -> expr XOR expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 108

    (46) expr -> expr GTE expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 46 (expr -> expr GTE expr .)
    DOTMINUS        reduce using rule 46 (expr -> expr GTE expr .)
    DOTPLUS         reduce using rule 46 (expr -> expr GTE expr .)
    DOTDIVIDE       reduce using rule 46 (expr -> expr GTE expr .)
    DOTMULTIPLY     reduce using rule 46 (expr -> expr GTE expr .)
    OR              reduce using rule 46 (expr -> expr GTE expr .)
    AND             reduce using rule 46 (expr -> expr GTE expr .)
    XOR             reduce using rule 46 (expr -> expr GTE expr .)
    GTE             reduce using rule 46 (expr -> expr GTE expr .)
    LTE             reduce using rule 46 (expr -> expr GTE expr .)
    GT              reduce using rule 46 (expr -> expr GTE expr .)
    LT              reduce using rule 46 (expr -> expr GTE expr .)
    NEQ             reduce using rule 46 (expr -> expr GTE expr .)
    EQ              reduce using rule 46 (expr -> expr GTE expr .)
    /               reduce using rule 46 (expr -> expr GTE expr .)
    *               reduce using rule 46 (expr -> expr GTE expr .)
    -               reduce using rule 46 (expr -> expr GTE expr .)
    +               reduce using rule 46 (expr -> expr GTE expr .)
    ;               reduce using rule 46 (expr -> expr GTE expr .)
    )               reduce using rule 46 (expr -> expr GTE expr .)
    ]               reduce using rule 46 (expr -> expr GTE expr .)
    :               reduce using rule 46 (expr -> expr GTE expr .)
    error           reduce using rule 46 (expr -> expr GTE expr .)
    {               reduce using rule 46 (expr -> expr GTE expr .)
    BREAK           reduce using rule 46 (expr -> expr GTE expr .)
    CONTINUE        reduce using rule 46 (expr -> expr GTE expr .)
    PRINT           reduce using rule 46 (expr -> expr GTE expr .)
    WHILE           reduce using rule 46 (expr -> expr GTE expr .)
    FOR             reduce using rule 46 (expr -> expr GTE expr .)
    RETURN          reduce using rule 46 (expr -> expr GTE expr .)
    IF              reduce using rule 46 (expr -> expr GTE expr .)
    ID              reduce using rule 46 (expr -> expr GTE expr .)
    '               shift and go to state 76


state 109

    (47) expr -> expr LTE expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 47 (expr -> expr LTE expr .)
    DOTMINUS        reduce using rule 47 (expr -> expr LTE expr .)
    DOTPLUS         reduce using rule 47 (expr -> expr LTE expr .)
    DOTDIVIDE       reduce using rule 47 (expr -> expr LTE expr .)
    DOTMULTIPLY     reduce using rule 47 (expr -> expr LTE expr .)
    OR              reduce using rule 47 (expr -> expr LTE expr .)
    AND             reduce using rule 47 (expr -> expr LTE expr .)
    XOR             reduce using rule 47 (expr -> expr LTE expr .)
    GTE             reduce using rule 47 (expr -> expr LTE expr .)
    LTE             reduce using rule 47 (expr -> expr LTE expr .)
    GT              reduce using rule 47 (expr -> expr LTE expr .)
    LT              reduce using rule 47 (expr -> expr LTE expr .)
    NEQ             reduce using rule 47 (expr -> expr LTE expr .)
    EQ              reduce using rule 47 (expr -> expr LTE expr .)
    /               reduce using rule 47 (expr -> expr LTE expr .)
    *               reduce using rule 47 (expr -> expr LTE expr .)
    -               reduce using rule 47 (expr -> expr LTE expr .)
    +               reduce using rule 47 (expr -> expr LTE expr .)
    ;               reduce using rule 47 (expr -> expr LTE expr .)
    )               reduce using rule 47 (expr -> expr LTE expr .)
    ]               reduce using rule 47 (expr -> expr LTE expr .)
    :               reduce using rule 47 (expr -> expr LTE expr .)
    error           reduce using rule 47 (expr -> expr LTE expr .)
    {               reduce using rule 47 (expr -> expr LTE expr .)
    BREAK           reduce using rule 47 (expr -> expr LTE expr .)
    CONTINUE        reduce using rule 47 (expr -> expr LTE expr .)
    PRINT           reduce using rule 47 (expr -> expr LTE expr .)
    WHILE           reduce using rule 47 (expr -> expr LTE expr .)
    FOR             reduce using rule 47 (expr -> expr LTE expr .)
    RETURN          reduce using rule 47 (expr -> expr LTE expr .)
    IF              reduce using rule 47 (expr -> expr LTE expr .)
    ID              reduce using rule 47 (expr -> expr LTE expr .)
    '               shift and go to state 76


state 110

    (48) expr -> expr GT expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 48 (expr -> expr GT expr .)
    DOTMINUS        reduce using rule 48 (expr -> expr GT expr .)
    DOTPLUS         reduce using rule 48 (expr -> expr GT expr .)
    DOTDIVIDE       reduce using rule 48 (expr -> expr GT expr .)
    DOTMULTIPLY     reduce using rule 48 (expr -> expr GT expr .)
    OR              reduce using rule 48 (expr -> expr GT expr .)
    AND             reduce using rule 48 (expr -> expr GT expr .)
    XOR             reduce using rule 48 (expr -> expr GT expr .)
    GTE             reduce using rule 48 (expr -> expr GT expr .)
    LTE             reduce using rule 48 (expr -> expr GT expr .)
    GT              reduce using rule 48 (expr -> expr GT expr .)
    LT              reduce using rule 48 (expr -> expr GT expr .)
    NEQ             reduce using rule 48 (expr -> expr GT expr .)
    EQ              reduce using rule 48 (expr -> expr GT expr .)
    /               reduce using rule 48 (expr -> expr GT expr .)
    *               reduce using rule 48 (expr -> expr GT expr .)
    -               reduce using rule 48 (expr -> expr GT expr .)
    +               reduce using rule 48 (expr -> expr GT expr .)
    ;               reduce using rule 48 (expr -> expr GT expr .)
    )               reduce using rule 48 (expr -> expr GT expr .)
    ]               reduce using rule 48 (expr -> expr GT expr .)
    :               reduce using rule 48 (expr -> expr GT expr .)
    error           reduce using rule 48 (expr -> expr GT expr .)
    {               reduce using rule 48 (expr -> expr GT expr .)
    BREAK           reduce using rule 48 (expr -> expr GT expr .)
    CONTINUE        reduce using rule 48 (expr -> expr GT expr .)
    PRINT           reduce using rule 48 (expr -> expr GT expr .)
    WHILE           reduce using rule 48 (expr -> expr GT expr .)
    FOR             reduce using rule 48 (expr -> expr GT expr .)
    RETURN          reduce using rule 48 (expr -> expr GT expr .)
    IF              reduce using rule 48 (expr -> expr GT expr .)
    ID              reduce using rule 48 (expr -> expr GT expr .)
    '               shift and go to state 76


state 111

    (49) expr -> expr LT expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 49 (expr -> expr LT expr .)
    DOTMINUS        reduce using rule 49 (expr -> expr LT expr .)
    DOTPLUS         reduce using rule 49 (expr -> expr LT expr .)
    DOTDIVIDE       reduce using rule 49 (expr -> expr LT expr .)
    DOTMULTIPLY     reduce using rule 49 (expr -> expr LT expr .)
    OR              reduce using rule 49 (expr -> expr LT expr .)
    AND             reduce using rule 49 (expr -> expr LT expr .)
    XOR             reduce using rule 49 (expr -> expr LT expr .)
    GTE             reduce using rule 49 (expr -> expr LT expr .)
    LTE             reduce using rule 49 (expr -> expr LT expr .)
    GT              reduce using rule 49 (expr -> expr LT expr .)
    LT              reduce using rule 49 (expr -> expr LT expr .)
    NEQ             reduce using rule 49 (expr -> expr LT expr .)
    EQ              reduce using rule 49 (expr -> expr LT expr .)
    /               reduce using rule 49 (expr -> expr LT expr .)
    *               reduce using rule 49 (expr -> expr LT expr .)
    -               reduce using rule 49 (expr -> expr LT expr .)
    +               reduce using rule 49 (expr -> expr LT expr .)
    ;               reduce using rule 49 (expr -> expr LT expr .)
    )               reduce using rule 49 (expr -> expr LT expr .)
    ]               reduce using rule 49 (expr -> expr LT expr .)
    :               reduce using rule 49 (expr -> expr LT expr .)
    error           reduce using rule 49 (expr -> expr LT expr .)
    {               reduce using rule 49 (expr -> expr LT expr .)
    BREAK           reduce using rule 49 (expr -> expr LT expr .)
    CONTINUE        reduce using rule 49 (expr -> expr LT expr .)
    PRINT           reduce using rule 49 (expr -> expr LT expr .)
    WHILE           reduce using rule 49 (expr -> expr LT expr .)
    FOR             reduce using rule 49 (expr -> expr LT expr .)
    RETURN          reduce using rule 49 (expr -> expr LT expr .)
    IF              reduce using rule 49 (expr -> expr LT expr .)
    ID              reduce using rule 49 (expr -> expr LT expr .)
    '               shift and go to state 76


state 112

    (50) expr -> expr NEQ expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 50 (expr -> expr NEQ expr .)
    DOTMINUS        reduce using rule 50 (expr -> expr NEQ expr .)
    DOTPLUS         reduce using rule 50 (expr -> expr NEQ expr .)
    DOTDIVIDE       reduce using rule 50 (expr -> expr NEQ expr .)
    DOTMULTIPLY     reduce using rule 50 (expr -> expr NEQ expr .)
    OR              reduce using rule 50 (expr -> expr NEQ expr .)
    AND             reduce using rule 50 (expr -> expr NEQ expr .)
    XOR             reduce using rule 50 (expr -> expr NEQ expr .)
    GTE             reduce using rule 50 (expr -> expr NEQ expr .)
    LTE             reduce using rule 50 (expr -> expr NEQ expr .)
    GT              reduce using rule 50 (expr -> expr NEQ expr .)
    LT              reduce using rule 50 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 50 (expr -> expr NEQ expr .)
    EQ              reduce using rule 50 (expr -> expr NEQ expr .)
    /               reduce using rule 50 (expr -> expr NEQ expr .)
    *               reduce using rule 50 (expr -> expr NEQ expr .)
    -               reduce using rule 50 (expr -> expr NEQ expr .)
    +               reduce using rule 50 (expr -> expr NEQ expr .)
    ;               reduce using rule 50 (expr -> expr NEQ expr .)
    )               reduce using rule 50 (expr -> expr NEQ expr .)
    ]               reduce using rule 50 (expr -> expr NEQ expr .)
    :               reduce using rule 50 (expr -> expr NEQ expr .)
    error           reduce using rule 50 (expr -> expr NEQ expr .)
    {               reduce using rule 50 (expr -> expr NEQ expr .)
    BREAK           reduce using rule 50 (expr -> expr NEQ expr .)
    CONTINUE        reduce using rule 50 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 50 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 50 (expr -> expr NEQ expr .)
    FOR             reduce using rule 50 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 50 (expr -> expr NEQ expr .)
    IF              reduce using rule 50 (expr -> expr NEQ expr .)
    ID              reduce using rule 50 (expr -> expr NEQ expr .)
    '               shift and go to state 76


state 113

    (51) expr -> expr EQ expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 51 (expr -> expr EQ expr .)
    DOTMINUS        reduce using rule 51 (expr -> expr EQ expr .)
    DOTPLUS         reduce using rule 51 (expr -> expr EQ expr .)
    DOTDIVIDE       reduce using rule 51 (expr -> expr EQ expr .)
    DOTMULTIPLY     reduce using rule 51 (expr -> expr EQ expr .)
    OR              reduce using rule 51 (expr -> expr EQ expr .)
    AND             reduce using rule 51 (expr -> expr EQ expr .)
    XOR             reduce using rule 51 (expr -> expr EQ expr .)
    GTE             reduce using rule 51 (expr -> expr EQ expr .)
    LTE             reduce using rule 51 (expr -> expr EQ expr .)
    GT              reduce using rule 51 (expr -> expr EQ expr .)
    LT              reduce using rule 51 (expr -> expr EQ expr .)
    NEQ             reduce using rule 51 (expr -> expr EQ expr .)
    EQ              reduce using rule 51 (expr -> expr EQ expr .)
    /               reduce using rule 51 (expr -> expr EQ expr .)
    *               reduce using rule 51 (expr -> expr EQ expr .)
    -               reduce using rule 51 (expr -> expr EQ expr .)
    +               reduce using rule 51 (expr -> expr EQ expr .)
    ;               reduce using rule 51 (expr -> expr EQ expr .)
    )               reduce using rule 51 (expr -> expr EQ expr .)
    ]               reduce using rule 51 (expr -> expr EQ expr .)
    :               reduce using rule 51 (expr -> expr EQ expr .)
    error           reduce using rule 51 (expr -> expr EQ expr .)
    {               reduce using rule 51 (expr -> expr EQ expr .)
    BREAK           reduce using rule 51 (expr -> expr EQ expr .)
    CONTINUE        reduce using rule 51 (expr -> expr EQ expr .)
    PRINT           reduce using rule 51 (expr -> expr EQ expr .)
    WHILE           reduce using rule 51 (expr -> expr EQ expr .)
    FOR             reduce using rule 51 (expr -> expr EQ expr .)
    RETURN          reduce using rule 51 (expr -> expr EQ expr .)
    IF              reduce using rule 51 (expr -> expr EQ expr .)
    ID              reduce using rule 51 (expr -> expr EQ expr .)
    '               shift and go to state 76


state 114

    (52) expr -> expr / expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 52 (expr -> expr / expr .)
    OR              reduce using rule 52 (expr -> expr / expr .)
    AND             reduce using rule 52 (expr -> expr / expr .)
    XOR             reduce using rule 52 (expr -> expr / expr .)
    /               reduce using rule 52 (expr -> expr / expr .)
    *               reduce using rule 52 (expr -> expr / expr .)
    -               reduce using rule 52 (expr -> expr / expr .)
    +               reduce using rule 52 (expr -> expr / expr .)
    ;               reduce using rule 52 (expr -> expr / expr .)
    )               reduce using rule 52 (expr -> expr / expr .)
    ]               reduce using rule 52 (expr -> expr / expr .)
    :               reduce using rule 52 (expr -> expr / expr .)
    error           reduce using rule 52 (expr -> expr / expr .)
    {               reduce using rule 52 (expr -> expr / expr .)
    BREAK           reduce using rule 52 (expr -> expr / expr .)
    CONTINUE        reduce using rule 52 (expr -> expr / expr .)
    PRINT           reduce using rule 52 (expr -> expr / expr .)
    WHILE           reduce using rule 52 (expr -> expr / expr .)
    FOR             reduce using rule 52 (expr -> expr / expr .)
    RETURN          reduce using rule 52 (expr -> expr / expr .)
    IF              reduce using rule 52 (expr -> expr / expr .)
    ID              reduce using rule 52 (expr -> expr / expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    '               shift and go to state 76


state 115

    (53) expr -> expr * expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 53 (expr -> expr * expr .)
    OR              reduce using rule 53 (expr -> expr * expr .)
    AND             reduce using rule 53 (expr -> expr * expr .)
    XOR             reduce using rule 53 (expr -> expr * expr .)
    /               reduce using rule 53 (expr -> expr * expr .)
    *               reduce using rule 53 (expr -> expr * expr .)
    -               reduce using rule 53 (expr -> expr * expr .)
    +               reduce using rule 53 (expr -> expr * expr .)
    ;               reduce using rule 53 (expr -> expr * expr .)
    )               reduce using rule 53 (expr -> expr * expr .)
    ]               reduce using rule 53 (expr -> expr * expr .)
    :               reduce using rule 53 (expr -> expr * expr .)
    error           reduce using rule 53 (expr -> expr * expr .)
    {               reduce using rule 53 (expr -> expr * expr .)
    BREAK           reduce using rule 53 (expr -> expr * expr .)
    CONTINUE        reduce using rule 53 (expr -> expr * expr .)
    PRINT           reduce using rule 53 (expr -> expr * expr .)
    WHILE           reduce using rule 53 (expr -> expr * expr .)
    FOR             reduce using rule 53 (expr -> expr * expr .)
    RETURN          reduce using rule 53 (expr -> expr * expr .)
    IF              reduce using rule 53 (expr -> expr * expr .)
    ID              reduce using rule 53 (expr -> expr * expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    '               shift and go to state 76


state 116

    (54) expr -> expr - expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 54 (expr -> expr - expr .)
    OR              reduce using rule 54 (expr -> expr - expr .)
    AND             reduce using rule 54 (expr -> expr - expr .)
    XOR             reduce using rule 54 (expr -> expr - expr .)
    -               reduce using rule 54 (expr -> expr - expr .)
    +               reduce using rule 54 (expr -> expr - expr .)
    ;               reduce using rule 54 (expr -> expr - expr .)
    )               reduce using rule 54 (expr -> expr - expr .)
    ]               reduce using rule 54 (expr -> expr - expr .)
    :               reduce using rule 54 (expr -> expr - expr .)
    error           reduce using rule 54 (expr -> expr - expr .)
    {               reduce using rule 54 (expr -> expr - expr .)
    BREAK           reduce using rule 54 (expr -> expr - expr .)
    CONTINUE        reduce using rule 54 (expr -> expr - expr .)
    PRINT           reduce using rule 54 (expr -> expr - expr .)
    WHILE           reduce using rule 54 (expr -> expr - expr .)
    FOR             reduce using rule 54 (expr -> expr - expr .)
    RETURN          reduce using rule 54 (expr -> expr - expr .)
    IF              reduce using rule 54 (expr -> expr - expr .)
    ID              reduce using rule 54 (expr -> expr - expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    '               shift and go to state 76


state 117

    (55) expr -> expr + expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ,               reduce using rule 55 (expr -> expr + expr .)
    OR              reduce using rule 55 (expr -> expr + expr .)
    AND             reduce using rule 55 (expr -> expr + expr .)
    XOR             reduce using rule 55 (expr -> expr + expr .)
    -               reduce using rule 55 (expr -> expr + expr .)
    +               reduce using rule 55 (expr -> expr + expr .)
    ;               reduce using rule 55 (expr -> expr + expr .)
    )               reduce using rule 55 (expr -> expr + expr .)
    ]               reduce using rule 55 (expr -> expr + expr .)
    :               reduce using rule 55 (expr -> expr + expr .)
    error           reduce using rule 55 (expr -> expr + expr .)
    {               reduce using rule 55 (expr -> expr + expr .)
    BREAK           reduce using rule 55 (expr -> expr + expr .)
    CONTINUE        reduce using rule 55 (expr -> expr + expr .)
    PRINT           reduce using rule 55 (expr -> expr + expr .)
    WHILE           reduce using rule 55 (expr -> expr + expr .)
    FOR             reduce using rule 55 (expr -> expr + expr .)
    RETURN          reduce using rule 55 (expr -> expr + expr .)
    IF              reduce using rule 55 (expr -> expr + expr .)
    ID              reduce using rule 55 (expr -> expr + expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    '               shift and go to state 76


state 118

    (36) expr -> mat_fun ( error . )
    )               shift and go to state 133


state 119

    (37) expr -> mat_fun ( mat_fun_args . )
    (86) mat_fun_args -> mat_fun_args . , expr
    )               shift and go to state 134
    ,               shift and go to state 135


state 120

    (85) mat_fun_args -> expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    )               reduce using rule 85 (mat_fun_args -> expr .)
    ,               reduce using rule 85 (mat_fun_args -> expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 121

    (57) expr -> ( expr ) .
    ,               reduce using rule 57 (expr -> ( expr ) .)
    DOTMINUS        reduce using rule 57 (expr -> ( expr ) .)
    DOTPLUS         reduce using rule 57 (expr -> ( expr ) .)
    DOTDIVIDE       reduce using rule 57 (expr -> ( expr ) .)
    DOTMULTIPLY     reduce using rule 57 (expr -> ( expr ) .)
    OR              reduce using rule 57 (expr -> ( expr ) .)
    AND             reduce using rule 57 (expr -> ( expr ) .)
    XOR             reduce using rule 57 (expr -> ( expr ) .)
    GTE             reduce using rule 57 (expr -> ( expr ) .)
    LTE             reduce using rule 57 (expr -> ( expr ) .)
    GT              reduce using rule 57 (expr -> ( expr ) .)
    LT              reduce using rule 57 (expr -> ( expr ) .)
    NEQ             reduce using rule 57 (expr -> ( expr ) .)
    EQ              reduce using rule 57 (expr -> ( expr ) .)
    /               reduce using rule 57 (expr -> ( expr ) .)
    *               reduce using rule 57 (expr -> ( expr ) .)
    -               reduce using rule 57 (expr -> ( expr ) .)
    +               reduce using rule 57 (expr -> ( expr ) .)
    '               reduce using rule 57 (expr -> ( expr ) .)
    ;               reduce using rule 57 (expr -> ( expr ) .)
    )               reduce using rule 57 (expr -> ( expr ) .)
    ]               reduce using rule 57 (expr -> ( expr ) .)
    :               reduce using rule 57 (expr -> ( expr ) .)
    error           reduce using rule 57 (expr -> ( expr ) .)
    {               reduce using rule 57 (expr -> ( expr ) .)
    BREAK           reduce using rule 57 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 57 (expr -> ( expr ) .)
    PRINT           reduce using rule 57 (expr -> ( expr ) .)
    WHILE           reduce using rule 57 (expr -> ( expr ) .)
    FOR             reduce using rule 57 (expr -> ( expr ) .)
    RETURN          reduce using rule 57 (expr -> ( expr ) .)
    IF              reduce using rule 57 (expr -> ( expr ) .)
    ID              reduce using rule 57 (expr -> ( expr ) .)


state 122

    (82) vector -> [ variables ] .
    ,               reduce using rule 82 (vector -> [ variables ] .)
    DOTMINUS        reduce using rule 82 (vector -> [ variables ] .)
    DOTPLUS         reduce using rule 82 (vector -> [ variables ] .)
    DOTDIVIDE       reduce using rule 82 (vector -> [ variables ] .)
    DOTMULTIPLY     reduce using rule 82 (vector -> [ variables ] .)
    OR              reduce using rule 82 (vector -> [ variables ] .)
    AND             reduce using rule 82 (vector -> [ variables ] .)
    XOR             reduce using rule 82 (vector -> [ variables ] .)
    GTE             reduce using rule 82 (vector -> [ variables ] .)
    LTE             reduce using rule 82 (vector -> [ variables ] .)
    GT              reduce using rule 82 (vector -> [ variables ] .)
    LT              reduce using rule 82 (vector -> [ variables ] .)
    NEQ             reduce using rule 82 (vector -> [ variables ] .)
    EQ              reduce using rule 82 (vector -> [ variables ] .)
    /               reduce using rule 82 (vector -> [ variables ] .)
    *               reduce using rule 82 (vector -> [ variables ] .)
    -               reduce using rule 82 (vector -> [ variables ] .)
    +               reduce using rule 82 (vector -> [ variables ] .)
    '               reduce using rule 82 (vector -> [ variables ] .)
    ;               reduce using rule 82 (vector -> [ variables ] .)
    )               reduce using rule 82 (vector -> [ variables ] .)
    ]               reduce using rule 82 (vector -> [ variables ] .)
    :               reduce using rule 82 (vector -> [ variables ] .)
    error           reduce using rule 82 (vector -> [ variables ] .)
    {               reduce using rule 82 (vector -> [ variables ] .)
    BREAK           reduce using rule 82 (vector -> [ variables ] .)
    CONTINUE        reduce using rule 82 (vector -> [ variables ] .)
    PRINT           reduce using rule 82 (vector -> [ variables ] .)
    WHILE           reduce using rule 82 (vector -> [ variables ] .)
    FOR             reduce using rule 82 (vector -> [ variables ] .)
    RETURN          reduce using rule 82 (vector -> [ variables ] .)
    IF              reduce using rule 82 (vector -> [ variables ] .)
    ID              reduce using rule 82 (vector -> [ variables ] .)


state 123

    (84) variables -> variables , . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 136
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 124

    (22) while_l -> WHILE ( expr ) . error
    (24) while_l -> WHILE ( expr ) . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 137
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 138
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 125

    (23) while_l -> WHILE ( error ) . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 139
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 126

    (25) for_l -> FOR ID = expr . : expr error
    (26) for_l -> FOR ID = expr . : error instruction
    (28) for_l -> FOR ID = expr . : expr instruction
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    :               shift and go to state 140
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 127

    (27) for_l -> FOR ID = error . : expr instruction
    :               shift and go to state 141


state 128

    (64) matel -> ID [ mat_ref_args ] .
    DIVIDEASSIGN    reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    MULTIPLYASSIGN  reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    MINUSASSIGN     reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    PLUSASSIGN      reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    =               reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    ,               reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    DOTMINUS        reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    DOTPLUS         reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    DOTDIVIDE       reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    DOTMULTIPLY     reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    OR              reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    AND             reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    XOR             reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    GTE             reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    LTE             reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    GT              reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    LT              reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    NEQ             reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    EQ              reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    /               reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    *               reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    -               reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    +               reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    '               reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    ;               reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    )               reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    ]               reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    :               reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    error           reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    {               reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    BREAK           reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    CONTINUE        reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    PRINT           reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    WHILE           reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    FOR             reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    RETURN          reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    IF              reduce using rule 64 (matel -> ID [ mat_ref_args ] .)
    ID              reduce using rule 64 (matel -> ID [ mat_ref_args ] .)


state 129

    (66) mat_ref_args -> mat_ref_args , . expr : expr
    (68) mat_ref_args -> mat_ref_args , . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 142
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 130

    (65) mat_ref_args -> expr : . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 143
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 131

    (15) if_i -> IF ( expr ) . instruction ELSE error
    (16) if_i -> IF ( expr ) . error ELSE instruction
    (17) if_i -> IF ( expr ) . error
    (20) if_i -> IF ( expr ) . instruction ELSE instruction
    (21) if_i -> IF ( expr ) . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 145
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 144
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 132

    (18) if_i -> IF ( error ) . instruction ELSE instruction
    (19) if_i -> IF ( error ) . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 146
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 133

    (36) expr -> mat_fun ( error ) .
    ,               reduce using rule 36 (expr -> mat_fun ( error ) .)
    DOTMINUS        reduce using rule 36 (expr -> mat_fun ( error ) .)
    DOTPLUS         reduce using rule 36 (expr -> mat_fun ( error ) .)
    DOTDIVIDE       reduce using rule 36 (expr -> mat_fun ( error ) .)
    DOTMULTIPLY     reduce using rule 36 (expr -> mat_fun ( error ) .)
    OR              reduce using rule 36 (expr -> mat_fun ( error ) .)
    AND             reduce using rule 36 (expr -> mat_fun ( error ) .)
    XOR             reduce using rule 36 (expr -> mat_fun ( error ) .)
    GTE             reduce using rule 36 (expr -> mat_fun ( error ) .)
    LTE             reduce using rule 36 (expr -> mat_fun ( error ) .)
    GT              reduce using rule 36 (expr -> mat_fun ( error ) .)
    LT              reduce using rule 36 (expr -> mat_fun ( error ) .)
    NEQ             reduce using rule 36 (expr -> mat_fun ( error ) .)
    EQ              reduce using rule 36 (expr -> mat_fun ( error ) .)
    /               reduce using rule 36 (expr -> mat_fun ( error ) .)
    *               reduce using rule 36 (expr -> mat_fun ( error ) .)
    -               reduce using rule 36 (expr -> mat_fun ( error ) .)
    +               reduce using rule 36 (expr -> mat_fun ( error ) .)
    '               reduce using rule 36 (expr -> mat_fun ( error ) .)
    ;               reduce using rule 36 (expr -> mat_fun ( error ) .)
    )               reduce using rule 36 (expr -> mat_fun ( error ) .)
    ]               reduce using rule 36 (expr -> mat_fun ( error ) .)
    :               reduce using rule 36 (expr -> mat_fun ( error ) .)
    error           reduce using rule 36 (expr -> mat_fun ( error ) .)
    {               reduce using rule 36 (expr -> mat_fun ( error ) .)
    BREAK           reduce using rule 36 (expr -> mat_fun ( error ) .)
    CONTINUE        reduce using rule 36 (expr -> mat_fun ( error ) .)
    PRINT           reduce using rule 36 (expr -> mat_fun ( error ) .)
    WHILE           reduce using rule 36 (expr -> mat_fun ( error ) .)
    FOR             reduce using rule 36 (expr -> mat_fun ( error ) .)
    RETURN          reduce using rule 36 (expr -> mat_fun ( error ) .)
    IF              reduce using rule 36 (expr -> mat_fun ( error ) .)
    ID              reduce using rule 36 (expr -> mat_fun ( error ) .)


state 134

    (37) expr -> mat_fun ( mat_fun_args ) .
    ,               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    DOTMINUS        reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    DOTPLUS         reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    DOTDIVIDE       reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    DOTMULTIPLY     reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    OR              reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    AND             reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    XOR             reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    GTE             reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    LTE             reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    GT              reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    LT              reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    NEQ             reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    EQ              reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    /               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    *               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    -               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    +               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    '               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    ;               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    )               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    ]               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    :               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    error           reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    {               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    BREAK           reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    CONTINUE        reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    PRINT           reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    WHILE           reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    FOR             reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    RETURN          reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    IF              reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    ID              reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)


state 135

    (86) mat_fun_args -> mat_fun_args , . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 147
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 136

    (84) variables -> variables , expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ]               reduce using rule 84 (variables -> variables , expr .)
    ,               reduce using rule 84 (variables -> variables , expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 137

    (22) while_l -> WHILE ( expr ) error .
    {               reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    BREAK           reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    CONTINUE        reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    PRINT           reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    WHILE           reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    FOR             reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    RETURN          reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    IF              reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    ID              reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    $end            reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    }               reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    ELSE            reduce using rule 22 (while_l -> WHILE ( expr ) error .)


state 138

    (24) while_l -> WHILE ( expr ) instruction .
    {               reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    BREAK           reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    CONTINUE        reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    PRINT           reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    WHILE           reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    FOR             reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    RETURN          reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    IF              reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    ID              reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    $end            reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    }               reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    ELSE            reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)


state 139

    (23) while_l -> WHILE ( error ) instruction .
    {               reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    BREAK           reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    CONTINUE        reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    PRINT           reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    WHILE           reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    FOR             reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    RETURN          reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    IF              reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    ID              reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    $end            reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    }               reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    ELSE            reduce using rule 23 (while_l -> WHILE ( error ) instruction .)


state 140

    (25) for_l -> FOR ID = expr : . expr error
    (26) for_l -> FOR ID = expr : . error instruction
    (28) for_l -> FOR ID = expr : . expr instruction
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 149
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 148
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 141

    (27) for_l -> FOR ID = error : . expr instruction
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 150
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 142

    (66) mat_ref_args -> mat_ref_args , expr . : expr
    (68) mat_ref_args -> mat_ref_args , expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    :               shift and go to state 151
    ]               reduce using rule 68 (mat_ref_args -> mat_ref_args , expr .)
    ,               reduce using rule 68 (mat_ref_args -> mat_ref_args , expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 143

    (65) mat_ref_args -> expr : expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ]               reduce using rule 65 (mat_ref_args -> expr : expr .)
    ,               reduce using rule 65 (mat_ref_args -> expr : expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 144

    (15) if_i -> IF ( expr ) instruction . ELSE error
    (20) if_i -> IF ( expr ) instruction . ELSE instruction
    (21) if_i -> IF ( expr ) instruction .
    ELSE            shift and go to state 152
    {               reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    BREAK           reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    CONTINUE        reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    PRINT           reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    WHILE           reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    FOR             reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    RETURN          reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    IF              reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    ID              reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    $end            reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    }               reduce using rule 21 (if_i -> IF ( expr ) instruction .)


state 145

    (16) if_i -> IF ( expr ) error . ELSE instruction
    (17) if_i -> IF ( expr ) error .
    ELSE            shift and go to state 153
    {               reduce using rule 17 (if_i -> IF ( expr ) error .)
    BREAK           reduce using rule 17 (if_i -> IF ( expr ) error .)
    CONTINUE        reduce using rule 17 (if_i -> IF ( expr ) error .)
    PRINT           reduce using rule 17 (if_i -> IF ( expr ) error .)
    WHILE           reduce using rule 17 (if_i -> IF ( expr ) error .)
    FOR             reduce using rule 17 (if_i -> IF ( expr ) error .)
    RETURN          reduce using rule 17 (if_i -> IF ( expr ) error .)
    IF              reduce using rule 17 (if_i -> IF ( expr ) error .)
    ID              reduce using rule 17 (if_i -> IF ( expr ) error .)
    $end            reduce using rule 17 (if_i -> IF ( expr ) error .)
    }               reduce using rule 17 (if_i -> IF ( expr ) error .)


state 146

    (18) if_i -> IF ( error ) instruction . ELSE instruction
    (19) if_i -> IF ( error ) instruction .
    ELSE            shift and go to state 154
    {               reduce using rule 19 (if_i -> IF ( error ) instruction .)
    BREAK           reduce using rule 19 (if_i -> IF ( error ) instruction .)
    CONTINUE        reduce using rule 19 (if_i -> IF ( error ) instruction .)
    PRINT           reduce using rule 19 (if_i -> IF ( error ) instruction .)
    WHILE           reduce using rule 19 (if_i -> IF ( error ) instruction .)
    FOR             reduce using rule 19 (if_i -> IF ( error ) instruction .)
    RETURN          reduce using rule 19 (if_i -> IF ( error ) instruction .)
    IF              reduce using rule 19 (if_i -> IF ( error ) instruction .)
    ID              reduce using rule 19 (if_i -> IF ( error ) instruction .)
    $end            reduce using rule 19 (if_i -> IF ( error ) instruction .)
    }               reduce using rule 19 (if_i -> IF ( error ) instruction .)


state 147

    (86) mat_fun_args -> mat_fun_args , expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    )               reduce using rule 86 (mat_fun_args -> mat_fun_args , expr .)
    ,               reduce using rule 86 (mat_fun_args -> mat_fun_args , expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 148

    (25) for_l -> FOR ID = expr : expr . error
    (28) for_l -> FOR ID = expr : expr . instruction
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 155
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 156
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 149

    (26) for_l -> FOR ID = expr : error . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 157
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 150

    (27) for_l -> FOR ID = error : expr . instruction
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 158
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 151

    (66) mat_ref_args -> mat_ref_args , expr : . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTMINUS expr
    (40) expr -> . expr DOTPLUS expr
    (41) expr -> . expr DOTDIVIDE expr
    (42) expr -> . expr DOTMULTIPLY expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GTE expr
    (47) expr -> . expr LTE expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr NEQ expr
    (51) expr -> . expr EQ expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (87) mat_fun -> . ONES
    (88) mat_fun -> . EYE
    (89) mat_fun -> . ZEROS
    (82) vector -> . [ variables ]
    (79) unary -> . expr '
    (80) unary -> . NOT expr
    (81) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 159
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 152

    (15) if_i -> IF ( expr ) instruction ELSE . error
    (20) if_i -> IF ( expr ) instruction ELSE . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    error           shift and go to state 161
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 160
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 153

    (16) if_i -> IF ( expr ) error ELSE . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 162
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 154

    (18) if_i -> IF ( error ) instruction ELSE . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (69) assign -> . var DIVIDEASSIGN error
    (70) assign -> . var MULTIPLYASSIGN error
    (71) assign -> . var MINUSASSIGN error
    (72) assign -> . var PLUSASSIGN error
    (73) assign -> . var = error
    (74) assign -> . var DIVIDEASSIGN expr
    (75) assign -> . var MULTIPLYASSIGN expr
    (76) assign -> . var MINUSASSIGN expr
    (77) assign -> . var PLUSASSIGN expr
    (78) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_ref_args ]
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 163
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 155

    (25) for_l -> FOR ID = expr : expr error .
    {               reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    BREAK           reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    CONTINUE        reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    PRINT           reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    WHILE           reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    FOR             reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    RETURN          reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    IF              reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    ID              reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    $end            reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    }               reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    ELSE            reduce using rule 25 (for_l -> FOR ID = expr : expr error .)


state 156

    (28) for_l -> FOR ID = expr : expr instruction .
    {               reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    BREAK           reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    CONTINUE        reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    PRINT           reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    WHILE           reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    FOR             reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    RETURN          reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    IF              reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    ID              reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    $end            reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    }               reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    ELSE            reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)


state 157

    (26) for_l -> FOR ID = expr : error instruction .
    {               reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    BREAK           reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    CONTINUE        reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    PRINT           reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    WHILE           reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    FOR             reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    RETURN          reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    IF              reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    ID              reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    $end            reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    }               reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    ELSE            reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)


state 158

    (27) for_l -> FOR ID = error : expr instruction .
    {               reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    BREAK           reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    CONTINUE        reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    PRINT           reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    WHILE           reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    FOR             reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    RETURN          reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    IF              reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    ID              reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    $end            reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    }               reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    ELSE            reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)


state 159

    (66) mat_ref_args -> mat_ref_args , expr : expr .
    (39) expr -> expr . DOTMINUS expr
    (40) expr -> expr . DOTPLUS expr
    (41) expr -> expr . DOTDIVIDE expr
    (42) expr -> expr . DOTMULTIPLY expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GTE expr
    (47) expr -> expr . LTE expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . NEQ expr
    (51) expr -> expr . EQ expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (79) unary -> expr . '
    ]               reduce using rule 66 (mat_ref_args -> mat_ref_args , expr : expr .)
    ,               reduce using rule 66 (mat_ref_args -> mat_ref_args , expr : expr .)
    DOTMINUS        shift and go to state 59
    DOTPLUS         shift and go to state 60
    DOTDIVIDE       shift and go to state 61
    DOTMULTIPLY     shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    GT              shift and go to state 68
    LT              shift and go to state 69
    NEQ             shift and go to state 70
    EQ              shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 160

    (20) if_i -> IF ( expr ) instruction ELSE instruction .
    {               reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    BREAK           reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    PRINT           reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    WHILE           reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    FOR             reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    RETURN          reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    IF              reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    ID              reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    $end            reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    }               reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    ELSE            reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)


state 161

    (15) if_i -> IF ( expr ) instruction ELSE error .
    {               reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    BREAK           reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    CONTINUE        reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    PRINT           reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    WHILE           reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    FOR             reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    RETURN          reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    IF              reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    ID              reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    $end            reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    }               reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    ELSE            reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)


state 162

    (16) if_i -> IF ( expr ) error ELSE instruction .
    {               reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    BREAK           reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    CONTINUE        reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    PRINT           reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    WHILE           reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    FOR             reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    RETURN          reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    IF              reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    ID              reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    $end            reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    }               reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    ELSE            reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)


state 163

    (18) if_i -> IF ( error ) instruction ELSE instruction .
    {               reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    BREAK           reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    PRINT           reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    WHILE           reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    FOR             reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    RETURN          reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    IF              reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    ID              reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    $end            reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    }               reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    ELSE            reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
