Grammar:

Rule 0     S' -> program
Rule 1     program -> instructions_or_empty
Rule 2     instructions_or_empty -> <empty>
Rule 3     instructions_or_empty -> instructions
Rule 4     instructions -> instruction
Rule 5     instructions -> instructions instruction
Rule 6     instruction -> { instructions }
Rule 7     instruction -> print_i ;
Rule 8     instruction -> assign ;
Rule 9     instruction -> while_l
Rule 10    instruction -> for_l
Rule 11    instruction -> CONTINUE ;
Rule 12    instruction -> BREAK ;
Rule 13    instruction -> return_i ;
Rule 14    instruction -> if_i
Rule 15    if_i -> IF ( expr ) instruction ELSE instruction  [precedence=right, level=2]
Rule 16    if_i -> IF ( expr ) instruction  [precedence=right, level=1]
Rule 17    while_l -> WHILE ( expr ) instruction
Rule 18    for_l -> FOR ID = expr : expr instruction
Rule 19    return_i -> RETURN expr
Rule 20    return_i -> RETURN
Rule 21    print_i -> PRINT printargs
Rule 22    printargs -> expr
Rule 23    printargs -> expr , printargs
Rule 24    expr -> mat_fun ( expr )
Rule 25    expr -> matrix
Rule 26    expr -> expr DOTMINUS expr  [precedence=left, level=6]
Rule 27    expr -> expr DOTPLUS expr  [precedence=left, level=6]
Rule 28    expr -> expr DOTDIVIDE expr  [precedence=left, level=7]
Rule 29    expr -> expr DOTMULTIPLY expr  [precedence=left, level=7]
Rule 30    expr -> expr OR expr  [precedence=left, level=9]
Rule 31    expr -> expr AND expr  [precedence=left, level=9]
Rule 32    expr -> expr XOR expr  [precedence=left, level=9]
Rule 33    expr -> expr GTE expr  [precedence=nonassoc, level=10]
Rule 34    expr -> expr LTE expr  [precedence=nonassoc, level=10]
Rule 35    expr -> expr GT expr  [precedence=nonassoc, level=10]
Rule 36    expr -> expr LT expr  [precedence=nonassoc, level=10]
Rule 37    expr -> expr NEQ expr  [precedence=nonassoc, level=10]
Rule 38    expr -> expr EQ expr  [precedence=nonassoc, level=10]
Rule 39    expr -> expr / expr  [precedence=left, level=5]
Rule 40    expr -> expr * expr  [precedence=left, level=5]
Rule 41    expr -> expr - expr  [precedence=left, level=4]
Rule 42    expr -> expr + expr  [precedence=left, level=4]
Rule 43    expr -> expr '  [precedence=left, level=11]
Rule 44    expr -> NOT expr  [precedence=right, level=12]
Rule 45    expr -> - expr  [precedence=right, level=12]
Rule 46    expr -> STRING
Rule 47    expr -> FLOATNUM
Rule 48    expr -> INTNUM
Rule 49    expr -> ( expr )
Rule 50    expr -> var
Rule 51    var -> matel
Rule 52    var -> ID
Rule 53    matel -> ID [ expr , expr ]
Rule 54    assign -> var DIVIDEASSIGN expr  [precedence=left, level=8]
Rule 55    assign -> var MULTIPLYASSIGN expr  [precedence=left, level=8]
Rule 56    assign -> var MINUSASSIGN expr  [precedence=left, level=8]
Rule 57    assign -> var PLUSASSIGN expr  [precedence=left, level=8]
Rule 58    assign -> var = expr  [precedence=left, level=8]
Rule 59    matrix -> [ vectors ]
Rule 60    vectors -> vector
Rule 61    vectors -> vectors , vector
Rule 62    vector -> [ variables ]
Rule 63    variables -> variable
Rule 64    variables -> variables , variable
Rule 65    variable -> expr
Rule 66    mat_fun -> ONES
Rule 67    mat_fun -> EYE
Rule 68    mat_fun -> ZEROS

Terminals, with rules where they appear:

'                    : 43
(                    : 15 16 17 24 49
)                    : 15 16 17 24 49
*                    : 40
+                    : 42
,                    : 23 53 61 64
-                    : 41 45
/                    : 39
:                    : 18
;                    : 7 8 11 12 13
=                    : 18 58
AND                  : 31
BREAK                : 12
CONTINUE             : 11
DIVIDEASSIGN         : 54
DOTDIVIDE            : 28
DOTMINUS             : 26
DOTMULTIPLY          : 29
DOTPLUS              : 27
ELSE                 : 15
EQ                   : 38
EYE                  : 67
FLOATNUM             : 47
FOR                  : 18
GT                   : 35
GTE                  : 33
ID                   : 18 52 53
IF                   : 15 16
INTNUM               : 48
LT                   : 36
LTE                  : 34
MINUSASSIGN          : 56
MULTIPLYASSIGN       : 55
NEQ                  : 37
NOT                  : 44
ONES                 : 66
OR                   : 30
PLUSASSIGN           : 57
PRINT                : 21
RETURN               : 19 20
STRING               : 46
WHILE                : 17
XOR                  : 32
ZEROS                : 68
[                    : 53 59 62
]                    : 53 59 62
error                : 
{                    : 6
}                    : 6

Nonterminals, with rules where they appear:

assign               : 8
expr                 : 15 16 17 18 18 19 22 23 24 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 44 45 49 53 53 54 55 56 57 58 65
for_l                : 10
if_i                 : 14
instruction          : 4 5 15 15 16 17 18
instructions         : 3 5 6
instructions_or_empty : 1
mat_fun              : 24
matel                : 51
matrix               : 25
print_i              : 7
printargs            : 21 23
program              : 0
return_i             : 13
var                  : 50 54 55 56 57 58
variable             : 63 64
variables            : 62 64
vector               : 60 61
vectors              : 59 61
while_l              : 9


state 0

    (0) S' -> . program
    (1) program -> . instructions_or_empty
    (2) instructions_or_empty -> .
    (3) instructions_or_empty -> . instructions
    (4) instructions -> . instruction
    (5) instructions -> . instructions instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . CONTINUE ;
    (12) instruction -> . BREAK ;
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (21) print_i -> . PRINT printargs
    (54) assign -> . var DIVIDEASSIGN expr
    (55) assign -> . var MULTIPLYASSIGN expr
    (56) assign -> . var MINUSASSIGN expr
    (57) assign -> . var PLUSASSIGN expr
    (58) assign -> . var = expr
    (17) while_l -> . WHILE ( expr ) instruction
    (18) for_l -> . FOR ID = expr : expr instruction
    (19) return_i -> . RETURN expr
    (20) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE instruction
    (16) if_i -> . IF ( expr ) instruction
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    $end            reduce using rule 2 (instructions_or_empty -> .)
    {               shift and go to state 5
    CONTINUE        shift and go to state 10
    BREAK           shift and go to state 11
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    program                        shift and go to state 1
    instructions_or_empty          shift and go to state 2
    instructions                   shift and go to state 3
    instruction                    shift and go to state 4
    print_i                        shift and go to state 6
    assign                         shift and go to state 7
    while_l                        shift and go to state 8
    for_l                          shift and go to state 9
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 1

    (0) S' -> program .


state 2

    (1) program -> instructions_or_empty .
    $end            reduce using rule 1 (program -> instructions_or_empty .)


state 3

    (3) instructions_or_empty -> instructions .
    (5) instructions -> instructions . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . CONTINUE ;
    (12) instruction -> . BREAK ;
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (21) print_i -> . PRINT printargs
    (54) assign -> . var DIVIDEASSIGN expr
    (55) assign -> . var MULTIPLYASSIGN expr
    (56) assign -> . var MINUSASSIGN expr
    (57) assign -> . var PLUSASSIGN expr
    (58) assign -> . var = expr
    (17) while_l -> . WHILE ( expr ) instruction
    (18) for_l -> . FOR ID = expr : expr instruction
    (19) return_i -> . RETURN expr
    (20) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE instruction
    (16) if_i -> . IF ( expr ) instruction
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    $end            reduce using rule 3 (instructions_or_empty -> instructions .)
    {               shift and go to state 5
    CONTINUE        shift and go to state 10
    BREAK           shift and go to state 11
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 22
    print_i                        shift and go to state 6
    assign                         shift and go to state 7
    while_l                        shift and go to state 8
    for_l                          shift and go to state 9
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 4

    (4) instructions -> instruction .
    {               reduce using rule 4 (instructions -> instruction .)
    CONTINUE        reduce using rule 4 (instructions -> instruction .)
    BREAK           reduce using rule 4 (instructions -> instruction .)
    PRINT           reduce using rule 4 (instructions -> instruction .)
    WHILE           reduce using rule 4 (instructions -> instruction .)
    FOR             reduce using rule 4 (instructions -> instruction .)
    RETURN          reduce using rule 4 (instructions -> instruction .)
    IF              reduce using rule 4 (instructions -> instruction .)
    ID              reduce using rule 4 (instructions -> instruction .)
    $end            reduce using rule 4 (instructions -> instruction .)
    }               reduce using rule 4 (instructions -> instruction .)


state 5

    (6) instruction -> { . instructions }
    (4) instructions -> . instruction
    (5) instructions -> . instructions instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . CONTINUE ;
    (12) instruction -> . BREAK ;
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (21) print_i -> . PRINT printargs
    (54) assign -> . var DIVIDEASSIGN expr
    (55) assign -> . var MULTIPLYASSIGN expr
    (56) assign -> . var MINUSASSIGN expr
    (57) assign -> . var PLUSASSIGN expr
    (58) assign -> . var = expr
    (17) while_l -> . WHILE ( expr ) instruction
    (18) for_l -> . FOR ID = expr : expr instruction
    (19) return_i -> . RETURN expr
    (20) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE instruction
    (16) if_i -> . IF ( expr ) instruction
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    {               shift and go to state 5
    CONTINUE        shift and go to state 10
    BREAK           shift and go to state 11
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instructions                   shift and go to state 23
    instruction                    shift and go to state 4
    print_i                        shift and go to state 6
    assign                         shift and go to state 7
    while_l                        shift and go to state 8
    for_l                          shift and go to state 9
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 6

    (7) instruction -> print_i . ;
    ;               shift and go to state 24


state 7

    (8) instruction -> assign . ;
    ;               shift and go to state 25


state 8

    (9) instruction -> while_l .
    {               reduce using rule 9 (instruction -> while_l .)
    CONTINUE        reduce using rule 9 (instruction -> while_l .)
    BREAK           reduce using rule 9 (instruction -> while_l .)
    PRINT           reduce using rule 9 (instruction -> while_l .)
    WHILE           reduce using rule 9 (instruction -> while_l .)
    FOR             reduce using rule 9 (instruction -> while_l .)
    RETURN          reduce using rule 9 (instruction -> while_l .)
    IF              reduce using rule 9 (instruction -> while_l .)
    ID              reduce using rule 9 (instruction -> while_l .)
    $end            reduce using rule 9 (instruction -> while_l .)
    }               reduce using rule 9 (instruction -> while_l .)
    ELSE            reduce using rule 9 (instruction -> while_l .)


state 9

    (10) instruction -> for_l .
    {               reduce using rule 10 (instruction -> for_l .)
    CONTINUE        reduce using rule 10 (instruction -> for_l .)
    BREAK           reduce using rule 10 (instruction -> for_l .)
    PRINT           reduce using rule 10 (instruction -> for_l .)
    WHILE           reduce using rule 10 (instruction -> for_l .)
    FOR             reduce using rule 10 (instruction -> for_l .)
    RETURN          reduce using rule 10 (instruction -> for_l .)
    IF              reduce using rule 10 (instruction -> for_l .)
    ID              reduce using rule 10 (instruction -> for_l .)
    $end            reduce using rule 10 (instruction -> for_l .)
    }               reduce using rule 10 (instruction -> for_l .)
    ELSE            reduce using rule 10 (instruction -> for_l .)


state 10

    (11) instruction -> CONTINUE . ;
    ;               shift and go to state 26


state 11

    (12) instruction -> BREAK . ;
    ;               shift and go to state 27


state 12

    (13) instruction -> return_i . ;
    ;               shift and go to state 28


state 13

    (14) instruction -> if_i .
    {               reduce using rule 14 (instruction -> if_i .)
    CONTINUE        reduce using rule 14 (instruction -> if_i .)
    BREAK           reduce using rule 14 (instruction -> if_i .)
    PRINT           reduce using rule 14 (instruction -> if_i .)
    WHILE           reduce using rule 14 (instruction -> if_i .)
    FOR             reduce using rule 14 (instruction -> if_i .)
    RETURN          reduce using rule 14 (instruction -> if_i .)
    IF              reduce using rule 14 (instruction -> if_i .)
    ID              reduce using rule 14 (instruction -> if_i .)
    $end            reduce using rule 14 (instruction -> if_i .)
    }               reduce using rule 14 (instruction -> if_i .)
    ELSE            reduce using rule 14 (instruction -> if_i .)


state 14

    (21) print_i -> PRINT . printargs
    (22) printargs -> . expr
    (23) printargs -> . expr , printargs
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    printargs                      shift and go to state 29
    expr                           shift and go to state 30
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 15

    (54) assign -> var . DIVIDEASSIGN expr
    (55) assign -> var . MULTIPLYASSIGN expr
    (56) assign -> var . MINUSASSIGN expr
    (57) assign -> var . PLUSASSIGN expr
    (58) assign -> var . = expr
    DIVIDEASSIGN    shift and go to state 44
    MULTIPLYASSIGN  shift and go to state 45
    MINUSASSIGN     shift and go to state 46
    PLUSASSIGN      shift and go to state 47
    =               shift and go to state 48


state 16

    (17) while_l -> WHILE . ( expr ) instruction
    (               shift and go to state 49


state 17

    (18) for_l -> FOR . ID = expr : expr instruction
    ID              shift and go to state 50


state 18

    (52) var -> ID .
    (53) matel -> ID . [ expr , expr ]
    DIVIDEASSIGN    reduce using rule 52 (var -> ID .)
    MULTIPLYASSIGN  reduce using rule 52 (var -> ID .)
    MINUSASSIGN     reduce using rule 52 (var -> ID .)
    PLUSASSIGN      reduce using rule 52 (var -> ID .)
    =               reduce using rule 52 (var -> ID .)
    ,               reduce using rule 52 (var -> ID .)
    DOTMINUS        reduce using rule 52 (var -> ID .)
    DOTPLUS         reduce using rule 52 (var -> ID .)
    DOTDIVIDE       reduce using rule 52 (var -> ID .)
    DOTMULTIPLY     reduce using rule 52 (var -> ID .)
    OR              reduce using rule 52 (var -> ID .)
    AND             reduce using rule 52 (var -> ID .)
    XOR             reduce using rule 52 (var -> ID .)
    GTE             reduce using rule 52 (var -> ID .)
    LTE             reduce using rule 52 (var -> ID .)
    GT              reduce using rule 52 (var -> ID .)
    LT              reduce using rule 52 (var -> ID .)
    NEQ             reduce using rule 52 (var -> ID .)
    EQ              reduce using rule 52 (var -> ID .)
    /               reduce using rule 52 (var -> ID .)
    *               reduce using rule 52 (var -> ID .)
    -               reduce using rule 52 (var -> ID .)
    +               reduce using rule 52 (var -> ID .)
    '               reduce using rule 52 (var -> ID .)
    ;               reduce using rule 52 (var -> ID .)
    )               reduce using rule 52 (var -> ID .)
    ]               reduce using rule 52 (var -> ID .)
    :               reduce using rule 52 (var -> ID .)
    {               reduce using rule 52 (var -> ID .)
    CONTINUE        reduce using rule 52 (var -> ID .)
    BREAK           reduce using rule 52 (var -> ID .)
    PRINT           reduce using rule 52 (var -> ID .)
    WHILE           reduce using rule 52 (var -> ID .)
    FOR             reduce using rule 52 (var -> ID .)
    RETURN          reduce using rule 52 (var -> ID .)
    IF              reduce using rule 52 (var -> ID .)
    ID              reduce using rule 52 (var -> ID .)
    [               shift and go to state 51


state 19

    (19) return_i -> RETURN . expr
    (20) return_i -> RETURN .
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    ;               reduce using rule 20 (return_i -> RETURN .)
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 52
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 20

    (15) if_i -> IF . ( expr ) instruction ELSE instruction
    (16) if_i -> IF . ( expr ) instruction
    (               shift and go to state 53


state 21

    (51) var -> matel .
    DIVIDEASSIGN    reduce using rule 51 (var -> matel .)
    MULTIPLYASSIGN  reduce using rule 51 (var -> matel .)
    MINUSASSIGN     reduce using rule 51 (var -> matel .)
    PLUSASSIGN      reduce using rule 51 (var -> matel .)
    =               reduce using rule 51 (var -> matel .)
    ,               reduce using rule 51 (var -> matel .)
    DOTMINUS        reduce using rule 51 (var -> matel .)
    DOTPLUS         reduce using rule 51 (var -> matel .)
    DOTDIVIDE       reduce using rule 51 (var -> matel .)
    DOTMULTIPLY     reduce using rule 51 (var -> matel .)
    OR              reduce using rule 51 (var -> matel .)
    AND             reduce using rule 51 (var -> matel .)
    XOR             reduce using rule 51 (var -> matel .)
    GTE             reduce using rule 51 (var -> matel .)
    LTE             reduce using rule 51 (var -> matel .)
    GT              reduce using rule 51 (var -> matel .)
    LT              reduce using rule 51 (var -> matel .)
    NEQ             reduce using rule 51 (var -> matel .)
    EQ              reduce using rule 51 (var -> matel .)
    /               reduce using rule 51 (var -> matel .)
    *               reduce using rule 51 (var -> matel .)
    -               reduce using rule 51 (var -> matel .)
    +               reduce using rule 51 (var -> matel .)
    '               reduce using rule 51 (var -> matel .)
    ;               reduce using rule 51 (var -> matel .)
    )               reduce using rule 51 (var -> matel .)
    ]               reduce using rule 51 (var -> matel .)
    :               reduce using rule 51 (var -> matel .)
    {               reduce using rule 51 (var -> matel .)
    CONTINUE        reduce using rule 51 (var -> matel .)
    BREAK           reduce using rule 51 (var -> matel .)
    PRINT           reduce using rule 51 (var -> matel .)
    WHILE           reduce using rule 51 (var -> matel .)
    FOR             reduce using rule 51 (var -> matel .)
    RETURN          reduce using rule 51 (var -> matel .)
    IF              reduce using rule 51 (var -> matel .)
    ID              reduce using rule 51 (var -> matel .)


state 22

    (5) instructions -> instructions instruction .
    {               reduce using rule 5 (instructions -> instructions instruction .)
    CONTINUE        reduce using rule 5 (instructions -> instructions instruction .)
    BREAK           reduce using rule 5 (instructions -> instructions instruction .)
    PRINT           reduce using rule 5 (instructions -> instructions instruction .)
    WHILE           reduce using rule 5 (instructions -> instructions instruction .)
    FOR             reduce using rule 5 (instructions -> instructions instruction .)
    RETURN          reduce using rule 5 (instructions -> instructions instruction .)
    IF              reduce using rule 5 (instructions -> instructions instruction .)
    ID              reduce using rule 5 (instructions -> instructions instruction .)
    $end            reduce using rule 5 (instructions -> instructions instruction .)
    }               reduce using rule 5 (instructions -> instructions instruction .)


state 23

    (6) instruction -> { instructions . }
    (5) instructions -> instructions . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . CONTINUE ;
    (12) instruction -> . BREAK ;
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (21) print_i -> . PRINT printargs
    (54) assign -> . var DIVIDEASSIGN expr
    (55) assign -> . var MULTIPLYASSIGN expr
    (56) assign -> . var MINUSASSIGN expr
    (57) assign -> . var PLUSASSIGN expr
    (58) assign -> . var = expr
    (17) while_l -> . WHILE ( expr ) instruction
    (18) for_l -> . FOR ID = expr : expr instruction
    (19) return_i -> . RETURN expr
    (20) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE instruction
    (16) if_i -> . IF ( expr ) instruction
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    }               shift and go to state 54
    {               shift and go to state 5
    CONTINUE        shift and go to state 10
    BREAK           shift and go to state 11
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 22
    print_i                        shift and go to state 6
    assign                         shift and go to state 7
    while_l                        shift and go to state 8
    for_l                          shift and go to state 9
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 24

    (7) instruction -> print_i ; .
    {               reduce using rule 7 (instruction -> print_i ; .)
    CONTINUE        reduce using rule 7 (instruction -> print_i ; .)
    BREAK           reduce using rule 7 (instruction -> print_i ; .)
    PRINT           reduce using rule 7 (instruction -> print_i ; .)
    WHILE           reduce using rule 7 (instruction -> print_i ; .)
    FOR             reduce using rule 7 (instruction -> print_i ; .)
    RETURN          reduce using rule 7 (instruction -> print_i ; .)
    IF              reduce using rule 7 (instruction -> print_i ; .)
    ID              reduce using rule 7 (instruction -> print_i ; .)
    $end            reduce using rule 7 (instruction -> print_i ; .)
    }               reduce using rule 7 (instruction -> print_i ; .)
    ELSE            reduce using rule 7 (instruction -> print_i ; .)


state 25

    (8) instruction -> assign ; .
    {               reduce using rule 8 (instruction -> assign ; .)
    CONTINUE        reduce using rule 8 (instruction -> assign ; .)
    BREAK           reduce using rule 8 (instruction -> assign ; .)
    PRINT           reduce using rule 8 (instruction -> assign ; .)
    WHILE           reduce using rule 8 (instruction -> assign ; .)
    FOR             reduce using rule 8 (instruction -> assign ; .)
    RETURN          reduce using rule 8 (instruction -> assign ; .)
    IF              reduce using rule 8 (instruction -> assign ; .)
    ID              reduce using rule 8 (instruction -> assign ; .)
    $end            reduce using rule 8 (instruction -> assign ; .)
    }               reduce using rule 8 (instruction -> assign ; .)
    ELSE            reduce using rule 8 (instruction -> assign ; .)


state 26

    (11) instruction -> CONTINUE ; .
    {               reduce using rule 11 (instruction -> CONTINUE ; .)
    CONTINUE        reduce using rule 11 (instruction -> CONTINUE ; .)
    BREAK           reduce using rule 11 (instruction -> CONTINUE ; .)
    PRINT           reduce using rule 11 (instruction -> CONTINUE ; .)
    WHILE           reduce using rule 11 (instruction -> CONTINUE ; .)
    FOR             reduce using rule 11 (instruction -> CONTINUE ; .)
    RETURN          reduce using rule 11 (instruction -> CONTINUE ; .)
    IF              reduce using rule 11 (instruction -> CONTINUE ; .)
    ID              reduce using rule 11 (instruction -> CONTINUE ; .)
    $end            reduce using rule 11 (instruction -> CONTINUE ; .)
    }               reduce using rule 11 (instruction -> CONTINUE ; .)
    ELSE            reduce using rule 11 (instruction -> CONTINUE ; .)


state 27

    (12) instruction -> BREAK ; .
    {               reduce using rule 12 (instruction -> BREAK ; .)
    CONTINUE        reduce using rule 12 (instruction -> BREAK ; .)
    BREAK           reduce using rule 12 (instruction -> BREAK ; .)
    PRINT           reduce using rule 12 (instruction -> BREAK ; .)
    WHILE           reduce using rule 12 (instruction -> BREAK ; .)
    FOR             reduce using rule 12 (instruction -> BREAK ; .)
    RETURN          reduce using rule 12 (instruction -> BREAK ; .)
    IF              reduce using rule 12 (instruction -> BREAK ; .)
    ID              reduce using rule 12 (instruction -> BREAK ; .)
    $end            reduce using rule 12 (instruction -> BREAK ; .)
    }               reduce using rule 12 (instruction -> BREAK ; .)
    ELSE            reduce using rule 12 (instruction -> BREAK ; .)


state 28

    (13) instruction -> return_i ; .
    {               reduce using rule 13 (instruction -> return_i ; .)
    CONTINUE        reduce using rule 13 (instruction -> return_i ; .)
    BREAK           reduce using rule 13 (instruction -> return_i ; .)
    PRINT           reduce using rule 13 (instruction -> return_i ; .)
    WHILE           reduce using rule 13 (instruction -> return_i ; .)
    FOR             reduce using rule 13 (instruction -> return_i ; .)
    RETURN          reduce using rule 13 (instruction -> return_i ; .)
    IF              reduce using rule 13 (instruction -> return_i ; .)
    ID              reduce using rule 13 (instruction -> return_i ; .)
    $end            reduce using rule 13 (instruction -> return_i ; .)
    }               reduce using rule 13 (instruction -> return_i ; .)
    ELSE            reduce using rule 13 (instruction -> return_i ; .)


state 29

    (21) print_i -> PRINT printargs .
    ;               reduce using rule 21 (print_i -> PRINT printargs .)


state 30

    (22) printargs -> expr .
    (23) printargs -> expr . , printargs
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ;               reduce using rule 22 (printargs -> expr .)
    ,               shift and go to state 55
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 31

    (24) expr -> mat_fun . ( expr )
    (               shift and go to state 74


state 32

    (49) expr -> ( . expr )
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 75
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 33

    (25) expr -> matrix .
    ,               reduce using rule 25 (expr -> matrix .)
    DOTMINUS        reduce using rule 25 (expr -> matrix .)
    DOTPLUS         reduce using rule 25 (expr -> matrix .)
    DOTDIVIDE       reduce using rule 25 (expr -> matrix .)
    DOTMULTIPLY     reduce using rule 25 (expr -> matrix .)
    OR              reduce using rule 25 (expr -> matrix .)
    AND             reduce using rule 25 (expr -> matrix .)
    XOR             reduce using rule 25 (expr -> matrix .)
    GTE             reduce using rule 25 (expr -> matrix .)
    LTE             reduce using rule 25 (expr -> matrix .)
    GT              reduce using rule 25 (expr -> matrix .)
    LT              reduce using rule 25 (expr -> matrix .)
    NEQ             reduce using rule 25 (expr -> matrix .)
    EQ              reduce using rule 25 (expr -> matrix .)
    /               reduce using rule 25 (expr -> matrix .)
    *               reduce using rule 25 (expr -> matrix .)
    -               reduce using rule 25 (expr -> matrix .)
    +               reduce using rule 25 (expr -> matrix .)
    '               reduce using rule 25 (expr -> matrix .)
    ;               reduce using rule 25 (expr -> matrix .)
    )               reduce using rule 25 (expr -> matrix .)
    ]               reduce using rule 25 (expr -> matrix .)
    :               reduce using rule 25 (expr -> matrix .)
    {               reduce using rule 25 (expr -> matrix .)
    CONTINUE        reduce using rule 25 (expr -> matrix .)
    BREAK           reduce using rule 25 (expr -> matrix .)
    PRINT           reduce using rule 25 (expr -> matrix .)
    WHILE           reduce using rule 25 (expr -> matrix .)
    FOR             reduce using rule 25 (expr -> matrix .)
    RETURN          reduce using rule 25 (expr -> matrix .)
    IF              reduce using rule 25 (expr -> matrix .)
    ID              reduce using rule 25 (expr -> matrix .)


state 34

    (45) expr -> - . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 76
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 35

    (44) expr -> NOT . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 77
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 36

    (46) expr -> STRING .
    ,               reduce using rule 46 (expr -> STRING .)
    DOTMINUS        reduce using rule 46 (expr -> STRING .)
    DOTPLUS         reduce using rule 46 (expr -> STRING .)
    DOTDIVIDE       reduce using rule 46 (expr -> STRING .)
    DOTMULTIPLY     reduce using rule 46 (expr -> STRING .)
    OR              reduce using rule 46 (expr -> STRING .)
    AND             reduce using rule 46 (expr -> STRING .)
    XOR             reduce using rule 46 (expr -> STRING .)
    GTE             reduce using rule 46 (expr -> STRING .)
    LTE             reduce using rule 46 (expr -> STRING .)
    GT              reduce using rule 46 (expr -> STRING .)
    LT              reduce using rule 46 (expr -> STRING .)
    NEQ             reduce using rule 46 (expr -> STRING .)
    EQ              reduce using rule 46 (expr -> STRING .)
    /               reduce using rule 46 (expr -> STRING .)
    *               reduce using rule 46 (expr -> STRING .)
    -               reduce using rule 46 (expr -> STRING .)
    +               reduce using rule 46 (expr -> STRING .)
    '               reduce using rule 46 (expr -> STRING .)
    ;               reduce using rule 46 (expr -> STRING .)
    )               reduce using rule 46 (expr -> STRING .)
    ]               reduce using rule 46 (expr -> STRING .)
    :               reduce using rule 46 (expr -> STRING .)
    {               reduce using rule 46 (expr -> STRING .)
    CONTINUE        reduce using rule 46 (expr -> STRING .)
    BREAK           reduce using rule 46 (expr -> STRING .)
    PRINT           reduce using rule 46 (expr -> STRING .)
    WHILE           reduce using rule 46 (expr -> STRING .)
    FOR             reduce using rule 46 (expr -> STRING .)
    RETURN          reduce using rule 46 (expr -> STRING .)
    IF              reduce using rule 46 (expr -> STRING .)
    ID              reduce using rule 46 (expr -> STRING .)


state 37

    (47) expr -> FLOATNUM .
    ,               reduce using rule 47 (expr -> FLOATNUM .)
    DOTMINUS        reduce using rule 47 (expr -> FLOATNUM .)
    DOTPLUS         reduce using rule 47 (expr -> FLOATNUM .)
    DOTDIVIDE       reduce using rule 47 (expr -> FLOATNUM .)
    DOTMULTIPLY     reduce using rule 47 (expr -> FLOATNUM .)
    OR              reduce using rule 47 (expr -> FLOATNUM .)
    AND             reduce using rule 47 (expr -> FLOATNUM .)
    XOR             reduce using rule 47 (expr -> FLOATNUM .)
    GTE             reduce using rule 47 (expr -> FLOATNUM .)
    LTE             reduce using rule 47 (expr -> FLOATNUM .)
    GT              reduce using rule 47 (expr -> FLOATNUM .)
    LT              reduce using rule 47 (expr -> FLOATNUM .)
    NEQ             reduce using rule 47 (expr -> FLOATNUM .)
    EQ              reduce using rule 47 (expr -> FLOATNUM .)
    /               reduce using rule 47 (expr -> FLOATNUM .)
    *               reduce using rule 47 (expr -> FLOATNUM .)
    -               reduce using rule 47 (expr -> FLOATNUM .)
    +               reduce using rule 47 (expr -> FLOATNUM .)
    '               reduce using rule 47 (expr -> FLOATNUM .)
    ;               reduce using rule 47 (expr -> FLOATNUM .)
    )               reduce using rule 47 (expr -> FLOATNUM .)
    ]               reduce using rule 47 (expr -> FLOATNUM .)
    :               reduce using rule 47 (expr -> FLOATNUM .)
    {               reduce using rule 47 (expr -> FLOATNUM .)
    CONTINUE        reduce using rule 47 (expr -> FLOATNUM .)
    BREAK           reduce using rule 47 (expr -> FLOATNUM .)
    PRINT           reduce using rule 47 (expr -> FLOATNUM .)
    WHILE           reduce using rule 47 (expr -> FLOATNUM .)
    FOR             reduce using rule 47 (expr -> FLOATNUM .)
    RETURN          reduce using rule 47 (expr -> FLOATNUM .)
    IF              reduce using rule 47 (expr -> FLOATNUM .)
    ID              reduce using rule 47 (expr -> FLOATNUM .)


state 38

    (48) expr -> INTNUM .
    ,               reduce using rule 48 (expr -> INTNUM .)
    DOTMINUS        reduce using rule 48 (expr -> INTNUM .)
    DOTPLUS         reduce using rule 48 (expr -> INTNUM .)
    DOTDIVIDE       reduce using rule 48 (expr -> INTNUM .)
    DOTMULTIPLY     reduce using rule 48 (expr -> INTNUM .)
    OR              reduce using rule 48 (expr -> INTNUM .)
    AND             reduce using rule 48 (expr -> INTNUM .)
    XOR             reduce using rule 48 (expr -> INTNUM .)
    GTE             reduce using rule 48 (expr -> INTNUM .)
    LTE             reduce using rule 48 (expr -> INTNUM .)
    GT              reduce using rule 48 (expr -> INTNUM .)
    LT              reduce using rule 48 (expr -> INTNUM .)
    NEQ             reduce using rule 48 (expr -> INTNUM .)
    EQ              reduce using rule 48 (expr -> INTNUM .)
    /               reduce using rule 48 (expr -> INTNUM .)
    *               reduce using rule 48 (expr -> INTNUM .)
    -               reduce using rule 48 (expr -> INTNUM .)
    +               reduce using rule 48 (expr -> INTNUM .)
    '               reduce using rule 48 (expr -> INTNUM .)
    ;               reduce using rule 48 (expr -> INTNUM .)
    )               reduce using rule 48 (expr -> INTNUM .)
    ]               reduce using rule 48 (expr -> INTNUM .)
    :               reduce using rule 48 (expr -> INTNUM .)
    {               reduce using rule 48 (expr -> INTNUM .)
    CONTINUE        reduce using rule 48 (expr -> INTNUM .)
    BREAK           reduce using rule 48 (expr -> INTNUM .)
    PRINT           reduce using rule 48 (expr -> INTNUM .)
    WHILE           reduce using rule 48 (expr -> INTNUM .)
    FOR             reduce using rule 48 (expr -> INTNUM .)
    RETURN          reduce using rule 48 (expr -> INTNUM .)
    IF              reduce using rule 48 (expr -> INTNUM .)
    ID              reduce using rule 48 (expr -> INTNUM .)


state 39

    (50) expr -> var .
    ,               reduce using rule 50 (expr -> var .)
    DOTMINUS        reduce using rule 50 (expr -> var .)
    DOTPLUS         reduce using rule 50 (expr -> var .)
    DOTDIVIDE       reduce using rule 50 (expr -> var .)
    DOTMULTIPLY     reduce using rule 50 (expr -> var .)
    OR              reduce using rule 50 (expr -> var .)
    AND             reduce using rule 50 (expr -> var .)
    XOR             reduce using rule 50 (expr -> var .)
    GTE             reduce using rule 50 (expr -> var .)
    LTE             reduce using rule 50 (expr -> var .)
    GT              reduce using rule 50 (expr -> var .)
    LT              reduce using rule 50 (expr -> var .)
    NEQ             reduce using rule 50 (expr -> var .)
    EQ              reduce using rule 50 (expr -> var .)
    /               reduce using rule 50 (expr -> var .)
    *               reduce using rule 50 (expr -> var .)
    -               reduce using rule 50 (expr -> var .)
    +               reduce using rule 50 (expr -> var .)
    '               reduce using rule 50 (expr -> var .)
    ;               reduce using rule 50 (expr -> var .)
    )               reduce using rule 50 (expr -> var .)
    ]               reduce using rule 50 (expr -> var .)
    :               reduce using rule 50 (expr -> var .)
    {               reduce using rule 50 (expr -> var .)
    CONTINUE        reduce using rule 50 (expr -> var .)
    BREAK           reduce using rule 50 (expr -> var .)
    PRINT           reduce using rule 50 (expr -> var .)
    WHILE           reduce using rule 50 (expr -> var .)
    FOR             reduce using rule 50 (expr -> var .)
    RETURN          reduce using rule 50 (expr -> var .)
    IF              reduce using rule 50 (expr -> var .)
    ID              reduce using rule 50 (expr -> var .)


state 40

    (66) mat_fun -> ONES .
    (               reduce using rule 66 (mat_fun -> ONES .)


state 41

    (67) mat_fun -> EYE .
    (               reduce using rule 67 (mat_fun -> EYE .)


state 42

    (68) mat_fun -> ZEROS .
    (               reduce using rule 68 (mat_fun -> ZEROS .)


state 43

    (59) matrix -> [ . vectors ]
    (60) vectors -> . vector
    (61) vectors -> . vectors , vector
    (62) vector -> . [ variables ]
    [               shift and go to state 78

    vectors                        shift and go to state 79
    vector                         shift and go to state 80

state 44

    (54) assign -> var DIVIDEASSIGN . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    var                            shift and go to state 39
    expr                           shift and go to state 81
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    matel                          shift and go to state 21

state 45

    (55) assign -> var MULTIPLYASSIGN . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    var                            shift and go to state 39
    expr                           shift and go to state 82
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    matel                          shift and go to state 21

state 46

    (56) assign -> var MINUSASSIGN . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    var                            shift and go to state 39
    expr                           shift and go to state 83
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    matel                          shift and go to state 21

state 47

    (57) assign -> var PLUSASSIGN . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    var                            shift and go to state 39
    expr                           shift and go to state 84
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    matel                          shift and go to state 21

state 48

    (58) assign -> var = . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    var                            shift and go to state 39
    expr                           shift and go to state 85
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    matel                          shift and go to state 21

state 49

    (17) while_l -> WHILE ( . expr ) instruction
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 86
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 50

    (18) for_l -> FOR ID . = expr : expr instruction
    =               shift and go to state 87


state 51

    (53) matel -> ID [ . expr , expr ]
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 88
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 52

    (19) return_i -> RETURN expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ;               reduce using rule 19 (return_i -> RETURN expr .)
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 53

    (15) if_i -> IF ( . expr ) instruction ELSE instruction
    (16) if_i -> IF ( . expr ) instruction
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 89
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 54

    (6) instruction -> { instructions } .
    {               reduce using rule 6 (instruction -> { instructions } .)
    CONTINUE        reduce using rule 6 (instruction -> { instructions } .)
    BREAK           reduce using rule 6 (instruction -> { instructions } .)
    PRINT           reduce using rule 6 (instruction -> { instructions } .)
    WHILE           reduce using rule 6 (instruction -> { instructions } .)
    FOR             reduce using rule 6 (instruction -> { instructions } .)
    RETURN          reduce using rule 6 (instruction -> { instructions } .)
    IF              reduce using rule 6 (instruction -> { instructions } .)
    ID              reduce using rule 6 (instruction -> { instructions } .)
    $end            reduce using rule 6 (instruction -> { instructions } .)
    }               reduce using rule 6 (instruction -> { instructions } .)
    ELSE            reduce using rule 6 (instruction -> { instructions } .)


state 55

    (23) printargs -> expr , . printargs
    (22) printargs -> . expr
    (23) printargs -> . expr , printargs
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 30
    printargs                      shift and go to state 90
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 56

    (26) expr -> expr DOTMINUS . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 91
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 57

    (27) expr -> expr DOTPLUS . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 92
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 58

    (28) expr -> expr DOTDIVIDE . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 93
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 59

    (29) expr -> expr DOTMULTIPLY . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 94
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 60

    (30) expr -> expr OR . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 95
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 61

    (31) expr -> expr AND . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 96
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 62

    (32) expr -> expr XOR . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 97
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 63

    (33) expr -> expr GTE . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 98
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 64

    (34) expr -> expr LTE . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 99
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 65

    (35) expr -> expr GT . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 100
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 66

    (36) expr -> expr LT . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 101
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 67

    (37) expr -> expr NEQ . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 102
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 68

    (38) expr -> expr EQ . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 103
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 69

    (39) expr -> expr / . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 104
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 70

    (40) expr -> expr * . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 105
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 71

    (41) expr -> expr - . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 106
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 72

    (42) expr -> expr + . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 107
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 73

    (43) expr -> expr ' .
    ,               reduce using rule 43 (expr -> expr ' .)
    DOTMINUS        reduce using rule 43 (expr -> expr ' .)
    DOTPLUS         reduce using rule 43 (expr -> expr ' .)
    DOTDIVIDE       reduce using rule 43 (expr -> expr ' .)
    DOTMULTIPLY     reduce using rule 43 (expr -> expr ' .)
    OR              reduce using rule 43 (expr -> expr ' .)
    AND             reduce using rule 43 (expr -> expr ' .)
    XOR             reduce using rule 43 (expr -> expr ' .)
    GTE             reduce using rule 43 (expr -> expr ' .)
    LTE             reduce using rule 43 (expr -> expr ' .)
    GT              reduce using rule 43 (expr -> expr ' .)
    LT              reduce using rule 43 (expr -> expr ' .)
    NEQ             reduce using rule 43 (expr -> expr ' .)
    EQ              reduce using rule 43 (expr -> expr ' .)
    /               reduce using rule 43 (expr -> expr ' .)
    *               reduce using rule 43 (expr -> expr ' .)
    -               reduce using rule 43 (expr -> expr ' .)
    +               reduce using rule 43 (expr -> expr ' .)
    '               reduce using rule 43 (expr -> expr ' .)
    ;               reduce using rule 43 (expr -> expr ' .)
    )               reduce using rule 43 (expr -> expr ' .)
    ]               reduce using rule 43 (expr -> expr ' .)
    :               reduce using rule 43 (expr -> expr ' .)
    {               reduce using rule 43 (expr -> expr ' .)
    CONTINUE        reduce using rule 43 (expr -> expr ' .)
    BREAK           reduce using rule 43 (expr -> expr ' .)
    PRINT           reduce using rule 43 (expr -> expr ' .)
    WHILE           reduce using rule 43 (expr -> expr ' .)
    FOR             reduce using rule 43 (expr -> expr ' .)
    RETURN          reduce using rule 43 (expr -> expr ' .)
    IF              reduce using rule 43 (expr -> expr ' .)
    ID              reduce using rule 43 (expr -> expr ' .)


state 74

    (24) expr -> mat_fun ( . expr )
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    mat_fun                        shift and go to state 31
    expr                           shift and go to state 108
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 75

    (49) expr -> ( expr . )
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    )               shift and go to state 109
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 76

    (45) expr -> - expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 45 (expr -> - expr .)
    DOTMINUS        reduce using rule 45 (expr -> - expr .)
    DOTPLUS         reduce using rule 45 (expr -> - expr .)
    DOTDIVIDE       reduce using rule 45 (expr -> - expr .)
    DOTMULTIPLY     reduce using rule 45 (expr -> - expr .)
    OR              reduce using rule 45 (expr -> - expr .)
    AND             reduce using rule 45 (expr -> - expr .)
    XOR             reduce using rule 45 (expr -> - expr .)
    GTE             reduce using rule 45 (expr -> - expr .)
    LTE             reduce using rule 45 (expr -> - expr .)
    GT              reduce using rule 45 (expr -> - expr .)
    LT              reduce using rule 45 (expr -> - expr .)
    NEQ             reduce using rule 45 (expr -> - expr .)
    EQ              reduce using rule 45 (expr -> - expr .)
    /               reduce using rule 45 (expr -> - expr .)
    *               reduce using rule 45 (expr -> - expr .)
    -               reduce using rule 45 (expr -> - expr .)
    +               reduce using rule 45 (expr -> - expr .)
    '               reduce using rule 45 (expr -> - expr .)
    ;               reduce using rule 45 (expr -> - expr .)
    )               reduce using rule 45 (expr -> - expr .)
    ]               reduce using rule 45 (expr -> - expr .)
    :               reduce using rule 45 (expr -> - expr .)
    {               reduce using rule 45 (expr -> - expr .)
    CONTINUE        reduce using rule 45 (expr -> - expr .)
    BREAK           reduce using rule 45 (expr -> - expr .)
    PRINT           reduce using rule 45 (expr -> - expr .)
    WHILE           reduce using rule 45 (expr -> - expr .)
    FOR             reduce using rule 45 (expr -> - expr .)
    RETURN          reduce using rule 45 (expr -> - expr .)
    IF              reduce using rule 45 (expr -> - expr .)
    ID              reduce using rule 45 (expr -> - expr .)


state 77

    (44) expr -> NOT expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 44 (expr -> NOT expr .)
    DOTMINUS        reduce using rule 44 (expr -> NOT expr .)
    DOTPLUS         reduce using rule 44 (expr -> NOT expr .)
    DOTDIVIDE       reduce using rule 44 (expr -> NOT expr .)
    DOTMULTIPLY     reduce using rule 44 (expr -> NOT expr .)
    OR              reduce using rule 44 (expr -> NOT expr .)
    AND             reduce using rule 44 (expr -> NOT expr .)
    XOR             reduce using rule 44 (expr -> NOT expr .)
    GTE             reduce using rule 44 (expr -> NOT expr .)
    LTE             reduce using rule 44 (expr -> NOT expr .)
    GT              reduce using rule 44 (expr -> NOT expr .)
    LT              reduce using rule 44 (expr -> NOT expr .)
    NEQ             reduce using rule 44 (expr -> NOT expr .)
    EQ              reduce using rule 44 (expr -> NOT expr .)
    /               reduce using rule 44 (expr -> NOT expr .)
    *               reduce using rule 44 (expr -> NOT expr .)
    -               reduce using rule 44 (expr -> NOT expr .)
    +               reduce using rule 44 (expr -> NOT expr .)
    '               reduce using rule 44 (expr -> NOT expr .)
    ;               reduce using rule 44 (expr -> NOT expr .)
    )               reduce using rule 44 (expr -> NOT expr .)
    ]               reduce using rule 44 (expr -> NOT expr .)
    :               reduce using rule 44 (expr -> NOT expr .)
    {               reduce using rule 44 (expr -> NOT expr .)
    CONTINUE        reduce using rule 44 (expr -> NOT expr .)
    BREAK           reduce using rule 44 (expr -> NOT expr .)
    PRINT           reduce using rule 44 (expr -> NOT expr .)
    WHILE           reduce using rule 44 (expr -> NOT expr .)
    FOR             reduce using rule 44 (expr -> NOT expr .)
    RETURN          reduce using rule 44 (expr -> NOT expr .)
    IF              reduce using rule 44 (expr -> NOT expr .)
    ID              reduce using rule 44 (expr -> NOT expr .)


state 78

    (62) vector -> [ . variables ]
    (63) variables -> . variable
    (64) variables -> . variables , variable
    (65) variable -> . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    variables                      shift and go to state 110
    variable                       shift and go to state 111
    expr                           shift and go to state 112
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 79

    (59) matrix -> [ vectors . ]
    (61) vectors -> vectors . , vector
    ]               shift and go to state 113
    ,               shift and go to state 114


state 80

    (60) vectors -> vector .
    ]               reduce using rule 60 (vectors -> vector .)
    ,               reduce using rule 60 (vectors -> vector .)


state 81

    (54) assign -> var DIVIDEASSIGN expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ;               reduce using rule 54 (assign -> var DIVIDEASSIGN expr .)
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 82

    (55) assign -> var MULTIPLYASSIGN expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ;               reduce using rule 55 (assign -> var MULTIPLYASSIGN expr .)
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 83

    (56) assign -> var MINUSASSIGN expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ;               reduce using rule 56 (assign -> var MINUSASSIGN expr .)
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 84

    (57) assign -> var PLUSASSIGN expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ;               reduce using rule 57 (assign -> var PLUSASSIGN expr .)
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 85

    (58) assign -> var = expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ;               reduce using rule 58 (assign -> var = expr .)
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 86

    (17) while_l -> WHILE ( expr . ) instruction
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    )               shift and go to state 115
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 87

    (18) for_l -> FOR ID = . expr : expr instruction
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 116
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 88

    (53) matel -> ID [ expr . , expr ]
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               shift and go to state 117
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 89

    (15) if_i -> IF ( expr . ) instruction ELSE instruction
    (16) if_i -> IF ( expr . ) instruction
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    )               shift and go to state 118
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 90

    (23) printargs -> expr , printargs .
    ;               reduce using rule 23 (printargs -> expr , printargs .)


state 91

    (26) expr -> expr DOTMINUS expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 26 (expr -> expr DOTMINUS expr .)
    DOTMINUS        reduce using rule 26 (expr -> expr DOTMINUS expr .)
    DOTPLUS         reduce using rule 26 (expr -> expr DOTMINUS expr .)
    /               reduce using rule 26 (expr -> expr DOTMINUS expr .)
    *               reduce using rule 26 (expr -> expr DOTMINUS expr .)
    -               reduce using rule 26 (expr -> expr DOTMINUS expr .)
    +               reduce using rule 26 (expr -> expr DOTMINUS expr .)
    '               reduce using rule 26 (expr -> expr DOTMINUS expr .)
    ;               reduce using rule 26 (expr -> expr DOTMINUS expr .)
    )               reduce using rule 26 (expr -> expr DOTMINUS expr .)
    ]               reduce using rule 26 (expr -> expr DOTMINUS expr .)
    :               reduce using rule 26 (expr -> expr DOTMINUS expr .)
    {               reduce using rule 26 (expr -> expr DOTMINUS expr .)
    CONTINUE        reduce using rule 26 (expr -> expr DOTMINUS expr .)
    BREAK           reduce using rule 26 (expr -> expr DOTMINUS expr .)
    PRINT           reduce using rule 26 (expr -> expr DOTMINUS expr .)
    WHILE           reduce using rule 26 (expr -> expr DOTMINUS expr .)
    FOR             reduce using rule 26 (expr -> expr DOTMINUS expr .)
    RETURN          reduce using rule 26 (expr -> expr DOTMINUS expr .)
    IF              reduce using rule 26 (expr -> expr DOTMINUS expr .)
    ID              reduce using rule 26 (expr -> expr DOTMINUS expr .)
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68


state 92

    (27) expr -> expr DOTPLUS expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 27 (expr -> expr DOTPLUS expr .)
    DOTMINUS        reduce using rule 27 (expr -> expr DOTPLUS expr .)
    DOTPLUS         reduce using rule 27 (expr -> expr DOTPLUS expr .)
    /               reduce using rule 27 (expr -> expr DOTPLUS expr .)
    *               reduce using rule 27 (expr -> expr DOTPLUS expr .)
    -               reduce using rule 27 (expr -> expr DOTPLUS expr .)
    +               reduce using rule 27 (expr -> expr DOTPLUS expr .)
    '               reduce using rule 27 (expr -> expr DOTPLUS expr .)
    ;               reduce using rule 27 (expr -> expr DOTPLUS expr .)
    )               reduce using rule 27 (expr -> expr DOTPLUS expr .)
    ]               reduce using rule 27 (expr -> expr DOTPLUS expr .)
    :               reduce using rule 27 (expr -> expr DOTPLUS expr .)
    {               reduce using rule 27 (expr -> expr DOTPLUS expr .)
    CONTINUE        reduce using rule 27 (expr -> expr DOTPLUS expr .)
    BREAK           reduce using rule 27 (expr -> expr DOTPLUS expr .)
    PRINT           reduce using rule 27 (expr -> expr DOTPLUS expr .)
    WHILE           reduce using rule 27 (expr -> expr DOTPLUS expr .)
    FOR             reduce using rule 27 (expr -> expr DOTPLUS expr .)
    RETURN          reduce using rule 27 (expr -> expr DOTPLUS expr .)
    IF              reduce using rule 27 (expr -> expr DOTPLUS expr .)
    ID              reduce using rule 27 (expr -> expr DOTPLUS expr .)
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68


state 93

    (28) expr -> expr DOTDIVIDE expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    DOTMINUS        reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    DOTPLUS         reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    DOTDIVIDE       reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    DOTMULTIPLY     reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    /               reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    *               reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    -               reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    +               reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    '               reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    ;               reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    )               reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    ]               reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    :               reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    {               reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    CONTINUE        reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    BREAK           reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    PRINT           reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    WHILE           reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    FOR             reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    RETURN          reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    IF              reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    ID              reduce using rule 28 (expr -> expr DOTDIVIDE expr .)
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68


state 94

    (29) expr -> expr DOTMULTIPLY expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    DOTMINUS        reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    DOTPLUS         reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    DOTDIVIDE       reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    DOTMULTIPLY     reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    /               reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    *               reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    -               reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    +               reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    '               reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    ;               reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    )               reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    ]               reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    :               reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    {               reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    CONTINUE        reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    BREAK           reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    PRINT           reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    WHILE           reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    FOR             reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    RETURN          reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    IF              reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    ID              reduce using rule 29 (expr -> expr DOTMULTIPLY expr .)
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68


state 95

    (30) expr -> expr OR expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 30 (expr -> expr OR expr .)
    DOTMINUS        reduce using rule 30 (expr -> expr OR expr .)
    DOTPLUS         reduce using rule 30 (expr -> expr OR expr .)
    DOTDIVIDE       reduce using rule 30 (expr -> expr OR expr .)
    DOTMULTIPLY     reduce using rule 30 (expr -> expr OR expr .)
    OR              reduce using rule 30 (expr -> expr OR expr .)
    AND             reduce using rule 30 (expr -> expr OR expr .)
    XOR             reduce using rule 30 (expr -> expr OR expr .)
    /               reduce using rule 30 (expr -> expr OR expr .)
    *               reduce using rule 30 (expr -> expr OR expr .)
    -               reduce using rule 30 (expr -> expr OR expr .)
    +               reduce using rule 30 (expr -> expr OR expr .)
    '               reduce using rule 30 (expr -> expr OR expr .)
    ;               reduce using rule 30 (expr -> expr OR expr .)
    )               reduce using rule 30 (expr -> expr OR expr .)
    ]               reduce using rule 30 (expr -> expr OR expr .)
    :               reduce using rule 30 (expr -> expr OR expr .)
    {               reduce using rule 30 (expr -> expr OR expr .)
    CONTINUE        reduce using rule 30 (expr -> expr OR expr .)
    BREAK           reduce using rule 30 (expr -> expr OR expr .)
    PRINT           reduce using rule 30 (expr -> expr OR expr .)
    WHILE           reduce using rule 30 (expr -> expr OR expr .)
    FOR             reduce using rule 30 (expr -> expr OR expr .)
    RETURN          reduce using rule 30 (expr -> expr OR expr .)
    IF              reduce using rule 30 (expr -> expr OR expr .)
    ID              reduce using rule 30 (expr -> expr OR expr .)
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68


state 96

    (31) expr -> expr AND expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 31 (expr -> expr AND expr .)
    DOTMINUS        reduce using rule 31 (expr -> expr AND expr .)
    DOTPLUS         reduce using rule 31 (expr -> expr AND expr .)
    DOTDIVIDE       reduce using rule 31 (expr -> expr AND expr .)
    DOTMULTIPLY     reduce using rule 31 (expr -> expr AND expr .)
    OR              reduce using rule 31 (expr -> expr AND expr .)
    AND             reduce using rule 31 (expr -> expr AND expr .)
    XOR             reduce using rule 31 (expr -> expr AND expr .)
    /               reduce using rule 31 (expr -> expr AND expr .)
    *               reduce using rule 31 (expr -> expr AND expr .)
    -               reduce using rule 31 (expr -> expr AND expr .)
    +               reduce using rule 31 (expr -> expr AND expr .)
    '               reduce using rule 31 (expr -> expr AND expr .)
    ;               reduce using rule 31 (expr -> expr AND expr .)
    )               reduce using rule 31 (expr -> expr AND expr .)
    ]               reduce using rule 31 (expr -> expr AND expr .)
    :               reduce using rule 31 (expr -> expr AND expr .)
    {               reduce using rule 31 (expr -> expr AND expr .)
    CONTINUE        reduce using rule 31 (expr -> expr AND expr .)
    BREAK           reduce using rule 31 (expr -> expr AND expr .)
    PRINT           reduce using rule 31 (expr -> expr AND expr .)
    WHILE           reduce using rule 31 (expr -> expr AND expr .)
    FOR             reduce using rule 31 (expr -> expr AND expr .)
    RETURN          reduce using rule 31 (expr -> expr AND expr .)
    IF              reduce using rule 31 (expr -> expr AND expr .)
    ID              reduce using rule 31 (expr -> expr AND expr .)
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68


state 97

    (32) expr -> expr XOR expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 32 (expr -> expr XOR expr .)
    DOTMINUS        reduce using rule 32 (expr -> expr XOR expr .)
    DOTPLUS         reduce using rule 32 (expr -> expr XOR expr .)
    DOTDIVIDE       reduce using rule 32 (expr -> expr XOR expr .)
    DOTMULTIPLY     reduce using rule 32 (expr -> expr XOR expr .)
    OR              reduce using rule 32 (expr -> expr XOR expr .)
    AND             reduce using rule 32 (expr -> expr XOR expr .)
    XOR             reduce using rule 32 (expr -> expr XOR expr .)
    /               reduce using rule 32 (expr -> expr XOR expr .)
    *               reduce using rule 32 (expr -> expr XOR expr .)
    -               reduce using rule 32 (expr -> expr XOR expr .)
    +               reduce using rule 32 (expr -> expr XOR expr .)
    '               reduce using rule 32 (expr -> expr XOR expr .)
    ;               reduce using rule 32 (expr -> expr XOR expr .)
    )               reduce using rule 32 (expr -> expr XOR expr .)
    ]               reduce using rule 32 (expr -> expr XOR expr .)
    :               reduce using rule 32 (expr -> expr XOR expr .)
    {               reduce using rule 32 (expr -> expr XOR expr .)
    CONTINUE        reduce using rule 32 (expr -> expr XOR expr .)
    BREAK           reduce using rule 32 (expr -> expr XOR expr .)
    PRINT           reduce using rule 32 (expr -> expr XOR expr .)
    WHILE           reduce using rule 32 (expr -> expr XOR expr .)
    FOR             reduce using rule 32 (expr -> expr XOR expr .)
    RETURN          reduce using rule 32 (expr -> expr XOR expr .)
    IF              reduce using rule 32 (expr -> expr XOR expr .)
    ID              reduce using rule 32 (expr -> expr XOR expr .)
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68


state 98

    (33) expr -> expr GTE expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 33 (expr -> expr GTE expr .)
    DOTMINUS        reduce using rule 33 (expr -> expr GTE expr .)
    DOTPLUS         reduce using rule 33 (expr -> expr GTE expr .)
    DOTDIVIDE       reduce using rule 33 (expr -> expr GTE expr .)
    DOTMULTIPLY     reduce using rule 33 (expr -> expr GTE expr .)
    OR              reduce using rule 33 (expr -> expr GTE expr .)
    AND             reduce using rule 33 (expr -> expr GTE expr .)
    XOR             reduce using rule 33 (expr -> expr GTE expr .)
    GTE             reduce using rule 33 (expr -> expr GTE expr .)
    LTE             reduce using rule 33 (expr -> expr GTE expr .)
    GT              reduce using rule 33 (expr -> expr GTE expr .)
    LT              reduce using rule 33 (expr -> expr GTE expr .)
    NEQ             reduce using rule 33 (expr -> expr GTE expr .)
    EQ              reduce using rule 33 (expr -> expr GTE expr .)
    /               reduce using rule 33 (expr -> expr GTE expr .)
    *               reduce using rule 33 (expr -> expr GTE expr .)
    -               reduce using rule 33 (expr -> expr GTE expr .)
    +               reduce using rule 33 (expr -> expr GTE expr .)
    '               reduce using rule 33 (expr -> expr GTE expr .)
    ;               reduce using rule 33 (expr -> expr GTE expr .)
    )               reduce using rule 33 (expr -> expr GTE expr .)
    ]               reduce using rule 33 (expr -> expr GTE expr .)
    :               reduce using rule 33 (expr -> expr GTE expr .)
    {               reduce using rule 33 (expr -> expr GTE expr .)
    CONTINUE        reduce using rule 33 (expr -> expr GTE expr .)
    BREAK           reduce using rule 33 (expr -> expr GTE expr .)
    PRINT           reduce using rule 33 (expr -> expr GTE expr .)
    WHILE           reduce using rule 33 (expr -> expr GTE expr .)
    FOR             reduce using rule 33 (expr -> expr GTE expr .)
    RETURN          reduce using rule 33 (expr -> expr GTE expr .)
    IF              reduce using rule 33 (expr -> expr GTE expr .)
    ID              reduce using rule 33 (expr -> expr GTE expr .)


state 99

    (34) expr -> expr LTE expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 34 (expr -> expr LTE expr .)
    DOTMINUS        reduce using rule 34 (expr -> expr LTE expr .)
    DOTPLUS         reduce using rule 34 (expr -> expr LTE expr .)
    DOTDIVIDE       reduce using rule 34 (expr -> expr LTE expr .)
    DOTMULTIPLY     reduce using rule 34 (expr -> expr LTE expr .)
    OR              reduce using rule 34 (expr -> expr LTE expr .)
    AND             reduce using rule 34 (expr -> expr LTE expr .)
    XOR             reduce using rule 34 (expr -> expr LTE expr .)
    GTE             reduce using rule 34 (expr -> expr LTE expr .)
    LTE             reduce using rule 34 (expr -> expr LTE expr .)
    GT              reduce using rule 34 (expr -> expr LTE expr .)
    LT              reduce using rule 34 (expr -> expr LTE expr .)
    NEQ             reduce using rule 34 (expr -> expr LTE expr .)
    EQ              reduce using rule 34 (expr -> expr LTE expr .)
    /               reduce using rule 34 (expr -> expr LTE expr .)
    *               reduce using rule 34 (expr -> expr LTE expr .)
    -               reduce using rule 34 (expr -> expr LTE expr .)
    +               reduce using rule 34 (expr -> expr LTE expr .)
    '               reduce using rule 34 (expr -> expr LTE expr .)
    ;               reduce using rule 34 (expr -> expr LTE expr .)
    )               reduce using rule 34 (expr -> expr LTE expr .)
    ]               reduce using rule 34 (expr -> expr LTE expr .)
    :               reduce using rule 34 (expr -> expr LTE expr .)
    {               reduce using rule 34 (expr -> expr LTE expr .)
    CONTINUE        reduce using rule 34 (expr -> expr LTE expr .)
    BREAK           reduce using rule 34 (expr -> expr LTE expr .)
    PRINT           reduce using rule 34 (expr -> expr LTE expr .)
    WHILE           reduce using rule 34 (expr -> expr LTE expr .)
    FOR             reduce using rule 34 (expr -> expr LTE expr .)
    RETURN          reduce using rule 34 (expr -> expr LTE expr .)
    IF              reduce using rule 34 (expr -> expr LTE expr .)
    ID              reduce using rule 34 (expr -> expr LTE expr .)


state 100

    (35) expr -> expr GT expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 35 (expr -> expr GT expr .)
    DOTMINUS        reduce using rule 35 (expr -> expr GT expr .)
    DOTPLUS         reduce using rule 35 (expr -> expr GT expr .)
    DOTDIVIDE       reduce using rule 35 (expr -> expr GT expr .)
    DOTMULTIPLY     reduce using rule 35 (expr -> expr GT expr .)
    OR              reduce using rule 35 (expr -> expr GT expr .)
    AND             reduce using rule 35 (expr -> expr GT expr .)
    XOR             reduce using rule 35 (expr -> expr GT expr .)
    GTE             reduce using rule 35 (expr -> expr GT expr .)
    LTE             reduce using rule 35 (expr -> expr GT expr .)
    GT              reduce using rule 35 (expr -> expr GT expr .)
    LT              reduce using rule 35 (expr -> expr GT expr .)
    NEQ             reduce using rule 35 (expr -> expr GT expr .)
    EQ              reduce using rule 35 (expr -> expr GT expr .)
    /               reduce using rule 35 (expr -> expr GT expr .)
    *               reduce using rule 35 (expr -> expr GT expr .)
    -               reduce using rule 35 (expr -> expr GT expr .)
    +               reduce using rule 35 (expr -> expr GT expr .)
    '               reduce using rule 35 (expr -> expr GT expr .)
    ;               reduce using rule 35 (expr -> expr GT expr .)
    )               reduce using rule 35 (expr -> expr GT expr .)
    ]               reduce using rule 35 (expr -> expr GT expr .)
    :               reduce using rule 35 (expr -> expr GT expr .)
    {               reduce using rule 35 (expr -> expr GT expr .)
    CONTINUE        reduce using rule 35 (expr -> expr GT expr .)
    BREAK           reduce using rule 35 (expr -> expr GT expr .)
    PRINT           reduce using rule 35 (expr -> expr GT expr .)
    WHILE           reduce using rule 35 (expr -> expr GT expr .)
    FOR             reduce using rule 35 (expr -> expr GT expr .)
    RETURN          reduce using rule 35 (expr -> expr GT expr .)
    IF              reduce using rule 35 (expr -> expr GT expr .)
    ID              reduce using rule 35 (expr -> expr GT expr .)


state 101

    (36) expr -> expr LT expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 36 (expr -> expr LT expr .)
    DOTMINUS        reduce using rule 36 (expr -> expr LT expr .)
    DOTPLUS         reduce using rule 36 (expr -> expr LT expr .)
    DOTDIVIDE       reduce using rule 36 (expr -> expr LT expr .)
    DOTMULTIPLY     reduce using rule 36 (expr -> expr LT expr .)
    OR              reduce using rule 36 (expr -> expr LT expr .)
    AND             reduce using rule 36 (expr -> expr LT expr .)
    XOR             reduce using rule 36 (expr -> expr LT expr .)
    GTE             reduce using rule 36 (expr -> expr LT expr .)
    LTE             reduce using rule 36 (expr -> expr LT expr .)
    GT              reduce using rule 36 (expr -> expr LT expr .)
    LT              reduce using rule 36 (expr -> expr LT expr .)
    NEQ             reduce using rule 36 (expr -> expr LT expr .)
    EQ              reduce using rule 36 (expr -> expr LT expr .)
    /               reduce using rule 36 (expr -> expr LT expr .)
    *               reduce using rule 36 (expr -> expr LT expr .)
    -               reduce using rule 36 (expr -> expr LT expr .)
    +               reduce using rule 36 (expr -> expr LT expr .)
    '               reduce using rule 36 (expr -> expr LT expr .)
    ;               reduce using rule 36 (expr -> expr LT expr .)
    )               reduce using rule 36 (expr -> expr LT expr .)
    ]               reduce using rule 36 (expr -> expr LT expr .)
    :               reduce using rule 36 (expr -> expr LT expr .)
    {               reduce using rule 36 (expr -> expr LT expr .)
    CONTINUE        reduce using rule 36 (expr -> expr LT expr .)
    BREAK           reduce using rule 36 (expr -> expr LT expr .)
    PRINT           reduce using rule 36 (expr -> expr LT expr .)
    WHILE           reduce using rule 36 (expr -> expr LT expr .)
    FOR             reduce using rule 36 (expr -> expr LT expr .)
    RETURN          reduce using rule 36 (expr -> expr LT expr .)
    IF              reduce using rule 36 (expr -> expr LT expr .)
    ID              reduce using rule 36 (expr -> expr LT expr .)


state 102

    (37) expr -> expr NEQ expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 37 (expr -> expr NEQ expr .)
    DOTMINUS        reduce using rule 37 (expr -> expr NEQ expr .)
    DOTPLUS         reduce using rule 37 (expr -> expr NEQ expr .)
    DOTDIVIDE       reduce using rule 37 (expr -> expr NEQ expr .)
    DOTMULTIPLY     reduce using rule 37 (expr -> expr NEQ expr .)
    OR              reduce using rule 37 (expr -> expr NEQ expr .)
    AND             reduce using rule 37 (expr -> expr NEQ expr .)
    XOR             reduce using rule 37 (expr -> expr NEQ expr .)
    GTE             reduce using rule 37 (expr -> expr NEQ expr .)
    LTE             reduce using rule 37 (expr -> expr NEQ expr .)
    GT              reduce using rule 37 (expr -> expr NEQ expr .)
    LT              reduce using rule 37 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 37 (expr -> expr NEQ expr .)
    EQ              reduce using rule 37 (expr -> expr NEQ expr .)
    /               reduce using rule 37 (expr -> expr NEQ expr .)
    *               reduce using rule 37 (expr -> expr NEQ expr .)
    -               reduce using rule 37 (expr -> expr NEQ expr .)
    +               reduce using rule 37 (expr -> expr NEQ expr .)
    '               reduce using rule 37 (expr -> expr NEQ expr .)
    ;               reduce using rule 37 (expr -> expr NEQ expr .)
    )               reduce using rule 37 (expr -> expr NEQ expr .)
    ]               reduce using rule 37 (expr -> expr NEQ expr .)
    :               reduce using rule 37 (expr -> expr NEQ expr .)
    {               reduce using rule 37 (expr -> expr NEQ expr .)
    CONTINUE        reduce using rule 37 (expr -> expr NEQ expr .)
    BREAK           reduce using rule 37 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 37 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 37 (expr -> expr NEQ expr .)
    FOR             reduce using rule 37 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 37 (expr -> expr NEQ expr .)
    IF              reduce using rule 37 (expr -> expr NEQ expr .)
    ID              reduce using rule 37 (expr -> expr NEQ expr .)


state 103

    (38) expr -> expr EQ expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 38 (expr -> expr EQ expr .)
    DOTMINUS        reduce using rule 38 (expr -> expr EQ expr .)
    DOTPLUS         reduce using rule 38 (expr -> expr EQ expr .)
    DOTDIVIDE       reduce using rule 38 (expr -> expr EQ expr .)
    DOTMULTIPLY     reduce using rule 38 (expr -> expr EQ expr .)
    OR              reduce using rule 38 (expr -> expr EQ expr .)
    AND             reduce using rule 38 (expr -> expr EQ expr .)
    XOR             reduce using rule 38 (expr -> expr EQ expr .)
    GTE             reduce using rule 38 (expr -> expr EQ expr .)
    LTE             reduce using rule 38 (expr -> expr EQ expr .)
    GT              reduce using rule 38 (expr -> expr EQ expr .)
    LT              reduce using rule 38 (expr -> expr EQ expr .)
    NEQ             reduce using rule 38 (expr -> expr EQ expr .)
    EQ              reduce using rule 38 (expr -> expr EQ expr .)
    /               reduce using rule 38 (expr -> expr EQ expr .)
    *               reduce using rule 38 (expr -> expr EQ expr .)
    -               reduce using rule 38 (expr -> expr EQ expr .)
    +               reduce using rule 38 (expr -> expr EQ expr .)
    '               reduce using rule 38 (expr -> expr EQ expr .)
    ;               reduce using rule 38 (expr -> expr EQ expr .)
    )               reduce using rule 38 (expr -> expr EQ expr .)
    ]               reduce using rule 38 (expr -> expr EQ expr .)
    :               reduce using rule 38 (expr -> expr EQ expr .)
    {               reduce using rule 38 (expr -> expr EQ expr .)
    CONTINUE        reduce using rule 38 (expr -> expr EQ expr .)
    BREAK           reduce using rule 38 (expr -> expr EQ expr .)
    PRINT           reduce using rule 38 (expr -> expr EQ expr .)
    WHILE           reduce using rule 38 (expr -> expr EQ expr .)
    FOR             reduce using rule 38 (expr -> expr EQ expr .)
    RETURN          reduce using rule 38 (expr -> expr EQ expr .)
    IF              reduce using rule 38 (expr -> expr EQ expr .)
    ID              reduce using rule 38 (expr -> expr EQ expr .)


state 104

    (39) expr -> expr / expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 39 (expr -> expr / expr .)
    /               reduce using rule 39 (expr -> expr / expr .)
    *               reduce using rule 39 (expr -> expr / expr .)
    -               reduce using rule 39 (expr -> expr / expr .)
    +               reduce using rule 39 (expr -> expr / expr .)
    '               reduce using rule 39 (expr -> expr / expr .)
    ;               reduce using rule 39 (expr -> expr / expr .)
    )               reduce using rule 39 (expr -> expr / expr .)
    ]               reduce using rule 39 (expr -> expr / expr .)
    :               reduce using rule 39 (expr -> expr / expr .)
    {               reduce using rule 39 (expr -> expr / expr .)
    CONTINUE        reduce using rule 39 (expr -> expr / expr .)
    BREAK           reduce using rule 39 (expr -> expr / expr .)
    PRINT           reduce using rule 39 (expr -> expr / expr .)
    WHILE           reduce using rule 39 (expr -> expr / expr .)
    FOR             reduce using rule 39 (expr -> expr / expr .)
    RETURN          reduce using rule 39 (expr -> expr / expr .)
    IF              reduce using rule 39 (expr -> expr / expr .)
    ID              reduce using rule 39 (expr -> expr / expr .)
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68


state 105

    (40) expr -> expr * expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 40 (expr -> expr * expr .)
    /               reduce using rule 40 (expr -> expr * expr .)
    *               reduce using rule 40 (expr -> expr * expr .)
    -               reduce using rule 40 (expr -> expr * expr .)
    +               reduce using rule 40 (expr -> expr * expr .)
    '               reduce using rule 40 (expr -> expr * expr .)
    ;               reduce using rule 40 (expr -> expr * expr .)
    )               reduce using rule 40 (expr -> expr * expr .)
    ]               reduce using rule 40 (expr -> expr * expr .)
    :               reduce using rule 40 (expr -> expr * expr .)
    {               reduce using rule 40 (expr -> expr * expr .)
    CONTINUE        reduce using rule 40 (expr -> expr * expr .)
    BREAK           reduce using rule 40 (expr -> expr * expr .)
    PRINT           reduce using rule 40 (expr -> expr * expr .)
    WHILE           reduce using rule 40 (expr -> expr * expr .)
    FOR             reduce using rule 40 (expr -> expr * expr .)
    RETURN          reduce using rule 40 (expr -> expr * expr .)
    IF              reduce using rule 40 (expr -> expr * expr .)
    ID              reduce using rule 40 (expr -> expr * expr .)
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68


state 106

    (41) expr -> expr - expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 41 (expr -> expr - expr .)
    -               reduce using rule 41 (expr -> expr - expr .)
    +               reduce using rule 41 (expr -> expr - expr .)
    '               reduce using rule 41 (expr -> expr - expr .)
    ;               reduce using rule 41 (expr -> expr - expr .)
    )               reduce using rule 41 (expr -> expr - expr .)
    ]               reduce using rule 41 (expr -> expr - expr .)
    :               reduce using rule 41 (expr -> expr - expr .)
    {               reduce using rule 41 (expr -> expr - expr .)
    CONTINUE        reduce using rule 41 (expr -> expr - expr .)
    BREAK           reduce using rule 41 (expr -> expr - expr .)
    PRINT           reduce using rule 41 (expr -> expr - expr .)
    WHILE           reduce using rule 41 (expr -> expr - expr .)
    FOR             reduce using rule 41 (expr -> expr - expr .)
    RETURN          reduce using rule 41 (expr -> expr - expr .)
    IF              reduce using rule 41 (expr -> expr - expr .)
    ID              reduce using rule 41 (expr -> expr - expr .)
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70


state 107

    (42) expr -> expr + expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ,               reduce using rule 42 (expr -> expr + expr .)
    -               reduce using rule 42 (expr -> expr + expr .)
    +               reduce using rule 42 (expr -> expr + expr .)
    '               reduce using rule 42 (expr -> expr + expr .)
    ;               reduce using rule 42 (expr -> expr + expr .)
    )               reduce using rule 42 (expr -> expr + expr .)
    ]               reduce using rule 42 (expr -> expr + expr .)
    :               reduce using rule 42 (expr -> expr + expr .)
    {               reduce using rule 42 (expr -> expr + expr .)
    CONTINUE        reduce using rule 42 (expr -> expr + expr .)
    BREAK           reduce using rule 42 (expr -> expr + expr .)
    PRINT           reduce using rule 42 (expr -> expr + expr .)
    WHILE           reduce using rule 42 (expr -> expr + expr .)
    FOR             reduce using rule 42 (expr -> expr + expr .)
    RETURN          reduce using rule 42 (expr -> expr + expr .)
    IF              reduce using rule 42 (expr -> expr + expr .)
    ID              reduce using rule 42 (expr -> expr + expr .)
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70


state 108

    (24) expr -> mat_fun ( expr . )
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    )               shift and go to state 119
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 109

    (49) expr -> ( expr ) .
    ,               reduce using rule 49 (expr -> ( expr ) .)
    DOTMINUS        reduce using rule 49 (expr -> ( expr ) .)
    DOTPLUS         reduce using rule 49 (expr -> ( expr ) .)
    DOTDIVIDE       reduce using rule 49 (expr -> ( expr ) .)
    DOTMULTIPLY     reduce using rule 49 (expr -> ( expr ) .)
    OR              reduce using rule 49 (expr -> ( expr ) .)
    AND             reduce using rule 49 (expr -> ( expr ) .)
    XOR             reduce using rule 49 (expr -> ( expr ) .)
    GTE             reduce using rule 49 (expr -> ( expr ) .)
    LTE             reduce using rule 49 (expr -> ( expr ) .)
    GT              reduce using rule 49 (expr -> ( expr ) .)
    LT              reduce using rule 49 (expr -> ( expr ) .)
    NEQ             reduce using rule 49 (expr -> ( expr ) .)
    EQ              reduce using rule 49 (expr -> ( expr ) .)
    /               reduce using rule 49 (expr -> ( expr ) .)
    *               reduce using rule 49 (expr -> ( expr ) .)
    -               reduce using rule 49 (expr -> ( expr ) .)
    +               reduce using rule 49 (expr -> ( expr ) .)
    '               reduce using rule 49 (expr -> ( expr ) .)
    ;               reduce using rule 49 (expr -> ( expr ) .)
    )               reduce using rule 49 (expr -> ( expr ) .)
    ]               reduce using rule 49 (expr -> ( expr ) .)
    :               reduce using rule 49 (expr -> ( expr ) .)
    {               reduce using rule 49 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 49 (expr -> ( expr ) .)
    BREAK           reduce using rule 49 (expr -> ( expr ) .)
    PRINT           reduce using rule 49 (expr -> ( expr ) .)
    WHILE           reduce using rule 49 (expr -> ( expr ) .)
    FOR             reduce using rule 49 (expr -> ( expr ) .)
    RETURN          reduce using rule 49 (expr -> ( expr ) .)
    IF              reduce using rule 49 (expr -> ( expr ) .)
    ID              reduce using rule 49 (expr -> ( expr ) .)


state 110

    (62) vector -> [ variables . ]
    (64) variables -> variables . , variable
    ]               shift and go to state 120
    ,               shift and go to state 121


state 111

    (63) variables -> variable .
    ]               reduce using rule 63 (variables -> variable .)
    ,               reduce using rule 63 (variables -> variable .)


state 112

    (65) variable -> expr .
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ]               reduce using rule 65 (variable -> expr .)
    ,               reduce using rule 65 (variable -> expr .)
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 113

    (59) matrix -> [ vectors ] .
    ,               reduce using rule 59 (matrix -> [ vectors ] .)
    DOTMINUS        reduce using rule 59 (matrix -> [ vectors ] .)
    DOTPLUS         reduce using rule 59 (matrix -> [ vectors ] .)
    DOTDIVIDE       reduce using rule 59 (matrix -> [ vectors ] .)
    DOTMULTIPLY     reduce using rule 59 (matrix -> [ vectors ] .)
    OR              reduce using rule 59 (matrix -> [ vectors ] .)
    AND             reduce using rule 59 (matrix -> [ vectors ] .)
    XOR             reduce using rule 59 (matrix -> [ vectors ] .)
    GTE             reduce using rule 59 (matrix -> [ vectors ] .)
    LTE             reduce using rule 59 (matrix -> [ vectors ] .)
    GT              reduce using rule 59 (matrix -> [ vectors ] .)
    LT              reduce using rule 59 (matrix -> [ vectors ] .)
    NEQ             reduce using rule 59 (matrix -> [ vectors ] .)
    EQ              reduce using rule 59 (matrix -> [ vectors ] .)
    /               reduce using rule 59 (matrix -> [ vectors ] .)
    *               reduce using rule 59 (matrix -> [ vectors ] .)
    -               reduce using rule 59 (matrix -> [ vectors ] .)
    +               reduce using rule 59 (matrix -> [ vectors ] .)
    '               reduce using rule 59 (matrix -> [ vectors ] .)
    ;               reduce using rule 59 (matrix -> [ vectors ] .)
    )               reduce using rule 59 (matrix -> [ vectors ] .)
    ]               reduce using rule 59 (matrix -> [ vectors ] .)
    :               reduce using rule 59 (matrix -> [ vectors ] .)
    {               reduce using rule 59 (matrix -> [ vectors ] .)
    CONTINUE        reduce using rule 59 (matrix -> [ vectors ] .)
    BREAK           reduce using rule 59 (matrix -> [ vectors ] .)
    PRINT           reduce using rule 59 (matrix -> [ vectors ] .)
    WHILE           reduce using rule 59 (matrix -> [ vectors ] .)
    FOR             reduce using rule 59 (matrix -> [ vectors ] .)
    RETURN          reduce using rule 59 (matrix -> [ vectors ] .)
    IF              reduce using rule 59 (matrix -> [ vectors ] .)
    ID              reduce using rule 59 (matrix -> [ vectors ] .)


state 114

    (61) vectors -> vectors , . vector
    (62) vector -> . [ variables ]
    [               shift and go to state 78

    vector                         shift and go to state 122

state 115

    (17) while_l -> WHILE ( expr ) . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . CONTINUE ;
    (12) instruction -> . BREAK ;
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (21) print_i -> . PRINT printargs
    (54) assign -> . var DIVIDEASSIGN expr
    (55) assign -> . var MULTIPLYASSIGN expr
    (56) assign -> . var MINUSASSIGN expr
    (57) assign -> . var PLUSASSIGN expr
    (58) assign -> . var = expr
    (17) while_l -> . WHILE ( expr ) instruction
    (18) for_l -> . FOR ID = expr : expr instruction
    (19) return_i -> . RETURN expr
    (20) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE instruction
    (16) if_i -> . IF ( expr ) instruction
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    {               shift and go to state 5
    CONTINUE        shift and go to state 10
    BREAK           shift and go to state 11
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 123
    print_i                        shift and go to state 6
    assign                         shift and go to state 7
    while_l                        shift and go to state 8
    for_l                          shift and go to state 9
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 116

    (18) for_l -> FOR ID = expr . : expr instruction
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    :               shift and go to state 124
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 117

    (53) matel -> ID [ expr , . expr ]
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 125
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 118

    (15) if_i -> IF ( expr ) . instruction ELSE instruction
    (16) if_i -> IF ( expr ) . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . CONTINUE ;
    (12) instruction -> . BREAK ;
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (21) print_i -> . PRINT printargs
    (54) assign -> . var DIVIDEASSIGN expr
    (55) assign -> . var MULTIPLYASSIGN expr
    (56) assign -> . var MINUSASSIGN expr
    (57) assign -> . var PLUSASSIGN expr
    (58) assign -> . var = expr
    (17) while_l -> . WHILE ( expr ) instruction
    (18) for_l -> . FOR ID = expr : expr instruction
    (19) return_i -> . RETURN expr
    (20) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE instruction
    (16) if_i -> . IF ( expr ) instruction
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    {               shift and go to state 5
    CONTINUE        shift and go to state 10
    BREAK           shift and go to state 11
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 126
    print_i                        shift and go to state 6
    assign                         shift and go to state 7
    while_l                        shift and go to state 8
    for_l                          shift and go to state 9
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 119

    (24) expr -> mat_fun ( expr ) .
    ,               reduce using rule 24 (expr -> mat_fun ( expr ) .)
    DOTMINUS        reduce using rule 24 (expr -> mat_fun ( expr ) .)
    DOTPLUS         reduce using rule 24 (expr -> mat_fun ( expr ) .)
    DOTDIVIDE       reduce using rule 24 (expr -> mat_fun ( expr ) .)
    DOTMULTIPLY     reduce using rule 24 (expr -> mat_fun ( expr ) .)
    OR              reduce using rule 24 (expr -> mat_fun ( expr ) .)
    AND             reduce using rule 24 (expr -> mat_fun ( expr ) .)
    XOR             reduce using rule 24 (expr -> mat_fun ( expr ) .)
    GTE             reduce using rule 24 (expr -> mat_fun ( expr ) .)
    LTE             reduce using rule 24 (expr -> mat_fun ( expr ) .)
    GT              reduce using rule 24 (expr -> mat_fun ( expr ) .)
    LT              reduce using rule 24 (expr -> mat_fun ( expr ) .)
    NEQ             reduce using rule 24 (expr -> mat_fun ( expr ) .)
    EQ              reduce using rule 24 (expr -> mat_fun ( expr ) .)
    /               reduce using rule 24 (expr -> mat_fun ( expr ) .)
    *               reduce using rule 24 (expr -> mat_fun ( expr ) .)
    -               reduce using rule 24 (expr -> mat_fun ( expr ) .)
    +               reduce using rule 24 (expr -> mat_fun ( expr ) .)
    '               reduce using rule 24 (expr -> mat_fun ( expr ) .)
    ;               reduce using rule 24 (expr -> mat_fun ( expr ) .)
    )               reduce using rule 24 (expr -> mat_fun ( expr ) .)
    ]               reduce using rule 24 (expr -> mat_fun ( expr ) .)
    :               reduce using rule 24 (expr -> mat_fun ( expr ) .)
    {               reduce using rule 24 (expr -> mat_fun ( expr ) .)
    CONTINUE        reduce using rule 24 (expr -> mat_fun ( expr ) .)
    BREAK           reduce using rule 24 (expr -> mat_fun ( expr ) .)
    PRINT           reduce using rule 24 (expr -> mat_fun ( expr ) .)
    WHILE           reduce using rule 24 (expr -> mat_fun ( expr ) .)
    FOR             reduce using rule 24 (expr -> mat_fun ( expr ) .)
    RETURN          reduce using rule 24 (expr -> mat_fun ( expr ) .)
    IF              reduce using rule 24 (expr -> mat_fun ( expr ) .)
    ID              reduce using rule 24 (expr -> mat_fun ( expr ) .)


state 120

    (62) vector -> [ variables ] .
    ]               reduce using rule 62 (vector -> [ variables ] .)
    ,               reduce using rule 62 (vector -> [ variables ] .)


state 121

    (64) variables -> variables , . variable
    (65) variable -> . expr
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    variable                       shift and go to state 127
    expr                           shift and go to state 112
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 122

    (61) vectors -> vectors , vector .
    ]               reduce using rule 61 (vectors -> vectors , vector .)
    ,               reduce using rule 61 (vectors -> vectors , vector .)


state 123

    (17) while_l -> WHILE ( expr ) instruction .
    {               reduce using rule 17 (while_l -> WHILE ( expr ) instruction .)
    CONTINUE        reduce using rule 17 (while_l -> WHILE ( expr ) instruction .)
    BREAK           reduce using rule 17 (while_l -> WHILE ( expr ) instruction .)
    PRINT           reduce using rule 17 (while_l -> WHILE ( expr ) instruction .)
    WHILE           reduce using rule 17 (while_l -> WHILE ( expr ) instruction .)
    FOR             reduce using rule 17 (while_l -> WHILE ( expr ) instruction .)
    RETURN          reduce using rule 17 (while_l -> WHILE ( expr ) instruction .)
    IF              reduce using rule 17 (while_l -> WHILE ( expr ) instruction .)
    ID              reduce using rule 17 (while_l -> WHILE ( expr ) instruction .)
    $end            reduce using rule 17 (while_l -> WHILE ( expr ) instruction .)
    }               reduce using rule 17 (while_l -> WHILE ( expr ) instruction .)
    ELSE            reduce using rule 17 (while_l -> WHILE ( expr ) instruction .)


state 124

    (18) for_l -> FOR ID = expr : . expr instruction
    (24) expr -> . mat_fun ( expr )
    (25) expr -> . matrix
    (26) expr -> . expr DOTMINUS expr
    (27) expr -> . expr DOTPLUS expr
    (28) expr -> . expr DOTDIVIDE expr
    (29) expr -> . expr DOTMULTIPLY expr
    (30) expr -> . expr OR expr
    (31) expr -> . expr AND expr
    (32) expr -> . expr XOR expr
    (33) expr -> . expr GTE expr
    (34) expr -> . expr LTE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr LT expr
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr - expr
    (42) expr -> . expr + expr
    (43) expr -> . expr '
    (44) expr -> . NOT expr
    (45) expr -> . - expr
    (46) expr -> . STRING
    (47) expr -> . FLOATNUM
    (48) expr -> . INTNUM
    (49) expr -> . ( expr )
    (50) expr -> . var
    (66) mat_fun -> . ONES
    (67) mat_fun -> . EYE
    (68) mat_fun -> . ZEROS
    (59) matrix -> . [ vectors ]
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    NOT             shift and go to state 35
    -               shift and go to state 34
    STRING          shift and go to state 36
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    (               shift and go to state 32
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    ID              shift and go to state 18

    expr                           shift and go to state 128
    mat_fun                        shift and go to state 31
    matrix                         shift and go to state 33
    var                            shift and go to state 39
    matel                          shift and go to state 21

state 125

    (53) matel -> ID [ expr , expr . ]
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    ]               shift and go to state 129
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73


state 126

    (15) if_i -> IF ( expr ) instruction . ELSE instruction
    (16) if_i -> IF ( expr ) instruction .
    ELSE            shift and go to state 130
    {               reduce using rule 16 (if_i -> IF ( expr ) instruction .)
    CONTINUE        reduce using rule 16 (if_i -> IF ( expr ) instruction .)
    BREAK           reduce using rule 16 (if_i -> IF ( expr ) instruction .)
    PRINT           reduce using rule 16 (if_i -> IF ( expr ) instruction .)
    WHILE           reduce using rule 16 (if_i -> IF ( expr ) instruction .)
    FOR             reduce using rule 16 (if_i -> IF ( expr ) instruction .)
    RETURN          reduce using rule 16 (if_i -> IF ( expr ) instruction .)
    IF              reduce using rule 16 (if_i -> IF ( expr ) instruction .)
    ID              reduce using rule 16 (if_i -> IF ( expr ) instruction .)
    $end            reduce using rule 16 (if_i -> IF ( expr ) instruction .)
    }               reduce using rule 16 (if_i -> IF ( expr ) instruction .)


state 127

    (64) variables -> variables , variable .
    ]               reduce using rule 64 (variables -> variables , variable .)
    ,               reduce using rule 64 (variables -> variables , variable .)


state 128

    (18) for_l -> FOR ID = expr : expr . instruction
    (26) expr -> expr . DOTMINUS expr
    (27) expr -> expr . DOTPLUS expr
    (28) expr -> expr . DOTDIVIDE expr
    (29) expr -> expr . DOTMULTIPLY expr
    (30) expr -> expr . OR expr
    (31) expr -> expr . AND expr
    (32) expr -> expr . XOR expr
    (33) expr -> expr . GTE expr
    (34) expr -> expr . LTE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . LT expr
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . - expr
    (42) expr -> expr . + expr
    (43) expr -> expr . '
    (6) instruction -> . { instructions }
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . CONTINUE ;
    (12) instruction -> . BREAK ;
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (21) print_i -> . PRINT printargs
    (54) assign -> . var DIVIDEASSIGN expr
    (55) assign -> . var MULTIPLYASSIGN expr
    (56) assign -> . var MINUSASSIGN expr
    (57) assign -> . var PLUSASSIGN expr
    (58) assign -> . var = expr
    (17) while_l -> . WHILE ( expr ) instruction
    (18) for_l -> . FOR ID = expr : expr instruction
    (19) return_i -> . RETURN expr
    (20) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE instruction
    (16) if_i -> . IF ( expr ) instruction
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    DOTMINUS        shift and go to state 56
    DOTPLUS         shift and go to state 57
    DOTDIVIDE       shift and go to state 58
    DOTMULTIPLY     shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    XOR             shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    NEQ             shift and go to state 67
    EQ              shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    '               shift and go to state 73
    {               shift and go to state 5
    CONTINUE        shift and go to state 10
    BREAK           shift and go to state 11
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 131
    print_i                        shift and go to state 6
    assign                         shift and go to state 7
    while_l                        shift and go to state 8
    for_l                          shift and go to state 9
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 129

    (53) matel -> ID [ expr , expr ] .
    DIVIDEASSIGN    reduce using rule 53 (matel -> ID [ expr , expr ] .)
    MULTIPLYASSIGN  reduce using rule 53 (matel -> ID [ expr , expr ] .)
    MINUSASSIGN     reduce using rule 53 (matel -> ID [ expr , expr ] .)
    PLUSASSIGN      reduce using rule 53 (matel -> ID [ expr , expr ] .)
    =               reduce using rule 53 (matel -> ID [ expr , expr ] .)
    ,               reduce using rule 53 (matel -> ID [ expr , expr ] .)
    DOTMINUS        reduce using rule 53 (matel -> ID [ expr , expr ] .)
    DOTPLUS         reduce using rule 53 (matel -> ID [ expr , expr ] .)
    DOTDIVIDE       reduce using rule 53 (matel -> ID [ expr , expr ] .)
    DOTMULTIPLY     reduce using rule 53 (matel -> ID [ expr , expr ] .)
    OR              reduce using rule 53 (matel -> ID [ expr , expr ] .)
    AND             reduce using rule 53 (matel -> ID [ expr , expr ] .)
    XOR             reduce using rule 53 (matel -> ID [ expr , expr ] .)
    GTE             reduce using rule 53 (matel -> ID [ expr , expr ] .)
    LTE             reduce using rule 53 (matel -> ID [ expr , expr ] .)
    GT              reduce using rule 53 (matel -> ID [ expr , expr ] .)
    LT              reduce using rule 53 (matel -> ID [ expr , expr ] .)
    NEQ             reduce using rule 53 (matel -> ID [ expr , expr ] .)
    EQ              reduce using rule 53 (matel -> ID [ expr , expr ] .)
    /               reduce using rule 53 (matel -> ID [ expr , expr ] .)
    *               reduce using rule 53 (matel -> ID [ expr , expr ] .)
    -               reduce using rule 53 (matel -> ID [ expr , expr ] .)
    +               reduce using rule 53 (matel -> ID [ expr , expr ] .)
    '               reduce using rule 53 (matel -> ID [ expr , expr ] .)
    ;               reduce using rule 53 (matel -> ID [ expr , expr ] .)
    )               reduce using rule 53 (matel -> ID [ expr , expr ] .)
    ]               reduce using rule 53 (matel -> ID [ expr , expr ] .)
    :               reduce using rule 53 (matel -> ID [ expr , expr ] .)
    {               reduce using rule 53 (matel -> ID [ expr , expr ] .)
    CONTINUE        reduce using rule 53 (matel -> ID [ expr , expr ] .)
    BREAK           reduce using rule 53 (matel -> ID [ expr , expr ] .)
    PRINT           reduce using rule 53 (matel -> ID [ expr , expr ] .)
    WHILE           reduce using rule 53 (matel -> ID [ expr , expr ] .)
    FOR             reduce using rule 53 (matel -> ID [ expr , expr ] .)
    RETURN          reduce using rule 53 (matel -> ID [ expr , expr ] .)
    IF              reduce using rule 53 (matel -> ID [ expr , expr ] .)
    ID              reduce using rule 53 (matel -> ID [ expr , expr ] .)


state 130

    (15) if_i -> IF ( expr ) instruction ELSE . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . CONTINUE ;
    (12) instruction -> . BREAK ;
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (21) print_i -> . PRINT printargs
    (54) assign -> . var DIVIDEASSIGN expr
    (55) assign -> . var MULTIPLYASSIGN expr
    (56) assign -> . var MINUSASSIGN expr
    (57) assign -> . var PLUSASSIGN expr
    (58) assign -> . var = expr
    (17) while_l -> . WHILE ( expr ) instruction
    (18) for_l -> . FOR ID = expr : expr instruction
    (19) return_i -> . RETURN expr
    (20) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE instruction
    (16) if_i -> . IF ( expr ) instruction
    (51) var -> . matel
    (52) var -> . ID
    (53) matel -> . ID [ expr , expr ]
    {               shift and go to state 5
    CONTINUE        shift and go to state 10
    BREAK           shift and go to state 11
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 132
    print_i                        shift and go to state 6
    assign                         shift and go to state 7
    while_l                        shift and go to state 8
    for_l                          shift and go to state 9
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 131

    (18) for_l -> FOR ID = expr : expr instruction .
    {               reduce using rule 18 (for_l -> FOR ID = expr : expr instruction .)
    CONTINUE        reduce using rule 18 (for_l -> FOR ID = expr : expr instruction .)
    BREAK           reduce using rule 18 (for_l -> FOR ID = expr : expr instruction .)
    PRINT           reduce using rule 18 (for_l -> FOR ID = expr : expr instruction .)
    WHILE           reduce using rule 18 (for_l -> FOR ID = expr : expr instruction .)
    FOR             reduce using rule 18 (for_l -> FOR ID = expr : expr instruction .)
    RETURN          reduce using rule 18 (for_l -> FOR ID = expr : expr instruction .)
    IF              reduce using rule 18 (for_l -> FOR ID = expr : expr instruction .)
    ID              reduce using rule 18 (for_l -> FOR ID = expr : expr instruction .)
    $end            reduce using rule 18 (for_l -> FOR ID = expr : expr instruction .)
    }               reduce using rule 18 (for_l -> FOR ID = expr : expr instruction .)
    ELSE            reduce using rule 18 (for_l -> FOR ID = expr : expr instruction .)


state 132

    (15) if_i -> IF ( expr ) instruction ELSE instruction .
    {               reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE instruction .)
    BREAK           reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE instruction .)
    PRINT           reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE instruction .)
    WHILE           reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE instruction .)
    FOR             reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE instruction .)
    RETURN          reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE instruction .)
    IF              reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE instruction .)
    ID              reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE instruction .)
    $end            reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE instruction .)
    }               reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE instruction .)
    ELSE            reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE instruction .)
